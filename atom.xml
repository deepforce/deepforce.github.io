<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Zack's Park]]></title>
  <subtitle><![CDATA[Welcome to weirdland！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://weirdforce.com/"/>
  <updated>2017-05-05T08:16:32.000Z</updated>
  <id>http://weirdforce.com/</id>
  
  <author>
    <name><![CDATA[Zack]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[编译原理之词法分析]]></title>
    <link href="http://weirdforce.com/2017/05/04/Compile/"/>
    <id>http://weirdforce.com/2017/05/04/Compile/</id>
    <published>2017-05-04T09:31:35.000Z</published>
    <updated>2017-05-05T08:16:32.000Z</updated>
    <content type="html"><![CDATA[<p>编译原理中的词法分析作业真的是折磨死我了。熬夜弄了一个不完美的版本。在此总结一下。<br><a id="more"></a><br>首先，我们要清楚地了解到整个程序的逻辑过程为如下几个过程：</p>
<blockquote>
<ol>
<li>正则表达式转换NFA</li>
<li>NFA转换DFA</li>
<li>DFA简化为最小化DFA</li>
<li>使用最小化DFA构建词法分析程序</li>
</ol>
</blockquote>
<p>很好，我们清晰地了解到这几个步骤之后，我们先来看<strong>正则表达式转换NFA</strong>。<br>思路如下：<br>要对输入的正则表达式进行分析，就如同之前学过的通过构建算术表达式的后缀表达式一样，我们需要通过区分正则表达式中<strong>符号</strong>及<strong>非符号</strong>，对正则表达式中符号的<strong>优先级</strong>进行先后的处理，这时，我们可以简单地想到使用栈来对符号和非符号进行存储。于是，得出一下结论：<br>数据结构：符号栈，NFA栈<br>然后，让我们进一步对非符号和符号进行分析：<br>非符号：这个很好分析，所有字母和$\epsilon$及$\varnothing$我们看作是最基本的NFA结构。可以构造如下：<br><img src="/images/basis.jpg" alt="Alt text"><br>符号：复杂的正则表达式拥有很多不同的运算符号，这里我们只对最基本的几种符号进行分析处理。<br>如：  </p>
<blockquote>
<p>“(“,左括号;<br>“)”,右括号;<br>“*“,重复符号;<br>“|”,选择符号;<br>“.”,连接符号; (P.S: 此符号一般不出现在正则表达式里，但我们在构建NFA的时候要进行判断是否存在连接运算并添加处理)</p>
</blockquote>
<p>下面来详细说明一下各符号的处理：<br>“(“, 左括号。最简单，只需压入符号栈即可。<br>“)”, 右括号。不需要压入符号栈，但遇到后需要弹出所有在”(“后面压入的运算符号，并进行运算。<br>“*“,重复符号。不需要压入符号栈，且在运算符号里的优先级最高。所以遇到后可以直接弹出NFA进行运算，再把运算得出的结果压入NFA栈里。<br>“|”,选择符号。优先级不如连接符号高，在遇到后，需要先将符号栈内比它优先级更高的符号弹出运算。注意，左括号不弹出，即遇到左括号弹出终止。所以这里需要将连接符号和选择符号（从左到右运算，所以优先级也比此符号高）弹出运算后，再将此符号压入符号栈。<br>“.”,连接符号。由于正则表达式中不会真正出现连接符号，所以我们应该分析在哪个时候添加连接符号。我们可以看出，在符号”)”,”*“后需要判断下一个元素是否为非符号或左括号，然后在其后压入一个连接符号入栈。同理，在非符号后也需要做上述判断和处理。</p>
<p>具体运算细节：  </p>
<ol>
<li>连接运算。需要弹出NFA栈中的两个NFA，将一个NFA的end连接到另一个NFA的start，再将新的NFA压入NFA栈内。</li>
<li>选择运算。需要弹出NFA栈中的两个NFA，重新分配两个新的节点，作为新的NFA的start和end，然后把新的NFA的start连到两个NFA的start中，两个NFA的end连到新的NFA的end中，再压入NFA栈。</li>
<li>闭包运算。需要弹出NFA栈中的一个NFA，然后重新分配两个新节点，作为新NFA的start和end, 然后新的start连接弹出的NFA的start，弹出的NFA的end连接新的end。然后新的start连到新的end的一条空边和旧的end连到旧的start的一条空边。最后把新的NFA压入NFA栈内。<br>如下图所示：<br><img src="/images/calculate.jpg" alt="Alt text"></li>
</ol>
<p>整个程序的具体过程应是如下：  </p>
<ol>
<li>用户输入一个正则表达式，用String来进行存储。  </li>
<li>遍历这个正则表达式，对非符号和符号做上文对应讲述的操作。</li>
<li>遍历完毕后，检查符号栈是否为空，若不为空，则弹出所有符号做对应的运算直至符号栈为空。</li>
<li>最后NFA栈中唯一的NFA就是所求的NFA。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>编译原理中的词法分析作业真的是折磨死我了。熬夜弄了一个不完美的版本。在此总结一下。<br>]]>
    
    </summary>
    
      <category term="Compile" scheme="http://weirdforce.com/tags/Compile/"/>
    
      <category term="编译原理" scheme="http://weirdforce.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="词法分析" scheme="http://weirdforce.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="Compile" scheme="http://weirdforce.com/categories/Compile/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[恢复使用]]></title>
    <link href="http://weirdforce.com/2017/04/28/resume/"/>
    <id>http://weirdforce.com/2017/04/28/resume/</id>
    <published>2017-04-28T07:11:15.000Z</published>
    <updated>2017-04-28T07:12:47.000Z</updated>
    <content type="html"><![CDATA[<p>总算重新布置好了博客，最近开始慢慢把这一年学到的东西进行详细的记录。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>总算重新布置好了博客，最近开始慢慢把这一年学到的东西进行详细的记录。</p>
]]>
    </summary>
    
      <category term="恢复" scheme="http://weirdforce.com/tags/%E6%81%A2%E5%A4%8D/"/>
    
      <category term="blog" scheme="http://weirdforce.com/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Exchange Cards]]></title>
    <link href="http://weirdforce.com/2016/05/19/Exchange-Cards/"/>
    <id>http://weirdforce.com/2016/05/19/Exchange-Cards/</id>
    <published>2016-05-19T07:05:30.000Z</published>
    <updated>2017-04-28T07:10:59.000Z</updated>
    <content type="html"><![CDATA[<p>题目讲述了一个等价交换卡片的故事，其实是为了统计一个价值为n的卡片有多少种组合方式。<br><strong> 题目链接:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2734" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>题目思路：</p>
<blockquote>
<p>根据现有卡片对能够构成价值n的卡片，进行DFS，找出所有能构成的方式，统计。</p>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="keyword">struct</span> card
{
<span class="keyword">int</span> val;
<span class="keyword">int</span> num;
}a[<span class="number">11</span>];
<span class="keyword">int</span> m;
<span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*p1, <span class="keyword">const</span> <span class="keyword">void</span>*p2)</span>
</span>{
<span class="keyword">return</span> (*(card*)p1).val&gt;(*(card*)p2).val?-<span class="number">1</span>:<span class="number">1</span>;
}
<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> start ,<span class="keyword">int</span> &amp;cnt)</span>
</span>{
      <span class="keyword">if</span>(sum==<span class="number">0</span>)
      {
          cnt++;
      }
      <span class="keyword">else</span>
      {
          <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;m;i++)
          {
              <span class="keyword">if</span>(a[i].val&lt;=sum &amp;&amp; a[i].num )
              {
                  sum-=a[i].val;
                  a[i].num--;
                  DFS(sum,i,cnt);
                  a[i].num++;
                  sum+=a[i].val;
              }
          }
      }
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> n;
<span class="keyword">int</span> cnt;
<span class="keyword">int</span> u=<span class="number">0</span>;
<span class="keyword">int</span> sum;
<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)
{
    <span class="keyword">if</span>(u)
            <span class="built_in">cout</span>&lt;&lt;endl;
    <span class="keyword">else</span>
            u++;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)
    {
      <span class="built_in">cin</span>&gt;&gt;a[i].val&gt;&gt;a[i].num;
    }

    qsort(a,m,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]),comp);
    cnt=<span class="number">0</span>;
    sum=n;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)
    {
      <span class="keyword">if</span>(a[i].val&lt;=n)
      {
          sum-=a[i].val;
          a[i].num--;
          DFS(sum,i,cnt);
          a[i].num++;
          sum+=a[i].val;
      }
    }
    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;endl;
}
<span class="keyword">return</span> <span class="number">0</span>;

}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>题目讲述了一个等价交换卡片的故事，其实是为了统计一个价值为n的卡片有多少种组合方式。<br><strong> 题目链接:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2734">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ZOJ" scheme="http://weirdforce.com/tags/ZOJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Eight]]></title>
    <link href="http://weirdforce.com/2016/05/19/Eight/"/>
    <id>http://weirdforce.com/2016/05/19/Eight/</id>
    <published>2016-05-19T06:57:35.000Z</published>
    <updated>2017-04-28T07:03:07.000Z</updated>
    <content type="html"><![CDATA[<p>这题题意很好理解，就是给定模版，然后每次输入一个例子，计算出转换成模版所需的路径。<br><strong> 题目链接: <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1217" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a></p>
<p>题目思路如下：</p>
<blockquote>
<ol>
<li>先将模版确定，并用DFS将所有可能移动到模版的情况的路径都统计出来。</li>
<li>输入给出的例子，并从所有的情况中找出对应的路径输出</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;M;
<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
   <span class="built_in">string</span> gold=<span class="string">"12345678x"</span>;
   <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator my_it;
   <span class="keyword">bool</span> flag[<span class="number">8</span>];
   <span class="keyword">int</span> n;
   <span class="keyword">int</span> a[<span class="number">4</span>]={<span class="number">1</span>,-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">3</span>};
   q.push(gold);
   M[gold]=gold;
   <span class="keyword">while</span>(!q.empty())
   {
        n=<span class="number">0</span>;
        <span class="built_in">string</span> s=q.front();
        q.pop();
        <span class="keyword">while</span>(s[n]!=<span class="string">'x'</span>)
        {
            n++;
        }
        <span class="built_in">string</span> ts;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)
        {
           ts=s;
           <span class="keyword">if</span>(n%<span class="number">3</span>+a[i]&gt;<span class="number">2</span>||n%<span class="number">3</span>+a[i]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;
           <span class="keyword">int</span> tx=n+a[i];
           <span class="keyword">char</span> tc;
           tc=ts[tx];
           ts[tx]=ts[n];
           ts[n]=tc;
           my_it = M.find(ts);
           <span class="keyword">if</span>(my_it==M.end())
           {
              q.push(ts);
              M[ts]=s;
           }
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">4</span>;i++)
        {
            ts=s;
            <span class="keyword">if</span>(n+a[i]&gt;=<span class="number">8</span>||n+a[i]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;
            <span class="keyword">int</span> tx=n+a[i];
            <span class="keyword">char</span> tc;
            tc=ts[tx];
            ts[tx]=ts[n];
            ts[n]=tc;
            my_it = M.find(ts);
            <span class="keyword">if</span>(my_it==M.end())
            {
                   q.push(ts);
                   M[ts]=s;
            }
         }
    }
    <span class="built_in">string</span> is;
    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,is))
    {
        <span class="keyword">int</span> begin = <span class="number">0</span>;

        begin = is.find(<span class="string">" "</span>,begin);  <span class="comment">//查找空格在str中第一次出现的位置</span>

        <span class="keyword">while</span>(begin != -<span class="number">1</span>)  <span class="comment">//表示字符串中存在空格</span>
        {
        is.replace(begin, <span class="number">1</span>, <span class="string">""</span>);  <span class="comment">// 用空串替换str中从begin开始的1个字符</span>
        begin = is.find(<span class="string">" "</span>,begin);  <span class="comment">//查找空格在替换后的str中第一次出现的位置</span>
        }
        my_it = M.find(is);
        <span class="keyword">if</span>(my_it==M.end())
        {
           <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsolvable"</span>&lt;&lt;endl;
           <span class="keyword">continue</span>;
        }
        <span class="built_in">string</span> str1,str2;
        <span class="keyword">int</span> w;
        str2=is;
        <span class="keyword">while</span>(<span class="number">1</span>)
        {
                str1=M[str2];
                <span class="keyword">int</span> ix=<span class="number">0</span>,iy=<span class="number">0</span>;
                <span class="keyword">while</span>(str1[ix]!=<span class="string">'x'</span>)
                {
                   ix++;
                }
                <span class="keyword">while</span>(str2[iy]!=<span class="string">'x'</span>)
                {
                   iy++;
                }
                <span class="keyword">switch</span>(ix-iy)
                {
                       <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"d"</span>;<span class="keyword">break</span>;
                       <span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"r"</span>;<span class="keyword">break</span>;
                       <span class="keyword">case</span> -<span class="number">1</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"l"</span>;<span class="keyword">break</span>;
                       <span class="keyword">case</span> -<span class="number">3</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"u"</span>;<span class="keyword">break</span>;
                }
                str2=str1;
                <span class="keyword">if</span>(str1==gold)
                       <span class="keyword">break</span>;
        }
        <span class="built_in">cout</span>&lt;&lt;endl;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这题题意很好理解，就是给定模版，然后每次输入一个例子，计算出转换成模版所需的路径。<br><strong> 题目链接: <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1217">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ZOJ" scheme="http://weirdforce.com/tags/ZOJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Additive equations]]></title>
    <link href="http://weirdforce.com/2016/05/19/Additive-equations/"/>
    <id>http://weirdforce.com/2016/05/19/Additive-equations/</id>
    <published>2016-05-19T06:50:24.000Z</published>
    <updated>2017-04-28T07:04:40.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 题目链接:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1204" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>这题题意为从一个数字序列中找出所有可能出现的等式。</p>
<p>题目思路如下：</p>
<blockquote>
<ol>
<li>如果单纯地采用枚举法一个个找出等式，绝对会超时。</li>
<li>故选择DFS，因为每个数字都有属于自己的等式，故借此对每个数字进行拆分，并记录所有情况，得到结果。</li>
</ol>
</blockquote>
<p>代码如下:</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="keyword">int</span> a[<span class="number">35</span>];
<span class="keyword">int</span> n;
<span class="keyword">bool</span> visit[<span class="number">35</span>],flag;

<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> len,<span class="keyword">int</span> start)</span>
</span>{
    <span class="keyword">if</span>(len==<span class="number">0</span>)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;n &amp;&amp; sum &gt;= a[i];i++)
        {
               <span class="keyword">if</span>(sum == a[i])
               {
                   flag = <span class="literal">true</span>;
                   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=i; j++)
                   {
                       <span class="keyword">if</span>(visit[j])
                       {
                               <span class="keyword">if</span>(sum == a[j])
                                   <span class="built_in">printf</span>(<span class="string">"%d=%d\n"</span>,a[j],a[i]);
                               <span class="keyword">else</span>
                                   <span class="built_in">printf</span>(<span class="string">"%d+"</span>,a[j]);
                               sum-=a[j];
                       }
                   }    
               }
             }
     }
     <span class="keyword">else</span>
     {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++)
        {
            <span class="keyword">if</span>(sum+a[i] &lt;= a[n-<span class="number">1</span>])
            {   
                len--;
                visit[i]=<span class="literal">true</span>;
                sum+=a[i];
                DFS(sum,len,i+<span class="number">1</span>);
                sum-=a[i];
                visit[i]=<span class="literal">false</span>;
                len++;
            }

        }

     }
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> t;
<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);
<span class="keyword">while</span>(t--)
{
<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);
sort(a,a+n);
<span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visit));                    
flag = <span class="literal">false</span>;
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n;i++)
        DFS(<span class="number">0</span>,i,<span class="number">0</span>);
<span class="keyword">if</span>(!flag)
        <span class="built_in">printf</span>(<span class="string">"Can't find any equations.\n\n"</span>);
<span class="keyword">else</span>
        <span class="built_in">printf</span>(<span class="string">"\n"</span>);
}

<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 题目链接:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1204">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ZOJ" scheme="http://weirdforce.com/tags/ZOJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016深圳杯笔记]]></title>
    <link href="http://weirdforce.com/2016/04/18/MCM-2016/"/>
    <id>http://weirdforce.com/2016/04/18/MCM-2016/</id>
    <published>2016-04-18T06:47:04.000Z</published>
    <updated>2017-04-28T06:49:15.000Z</updated>
    <content type="html"><![CDATA[<p>A题思路：<br>稳定性－&gt;单位面积烟尘排放量<br><a id="more"></a><br>影响稳定性的因素：</p>
<blockquote>
<p>布袋寿命<br>炉压差<br>布袋直径<br>喷嘴与布袋口中心偏差？<br>清洗频繁，喷吹压力过高<br>输灰系统<br>布袋底部强度</p>
</blockquote>
<p>除尘效果：</p>
<blockquote>
<p>烟气温度<br>烟道和本体漏风漏水</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>A题思路：<br>稳定性－&gt;单位面积烟尘排放量<br>]]>
    
    </summary>
    
      <category term="MCM" scheme="http://weirdforce.com/tags/MCM/"/>
    
      <category term="2016深圳杯" scheme="http://weirdforce.com/tags/2016%E6%B7%B1%E5%9C%B3%E6%9D%AF/"/>
    
      <category term="MCM" scheme="http://weirdforce.com/categories/MCM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015深圳杯数学建模A题笔记(2)]]></title>
    <link href="http://weirdforce.com/2016/04/09/MCM-note-2/"/>
    <id>http://weirdforce.com/2016/04/09/MCM-note-2/</id>
    <published>2016-04-09T06:39:05.000Z</published>
    <updated>2017-04-28T06:46:53.000Z</updated>
    <content type="html"><![CDATA[<p>采用基于分辨率的孤立点算法（RB算法）<br>RB算法：</p>
<blockquote>
<p><strong>优点：</strong> 适用于海量的数据库，无需引入参数<br><strong>缺点：</strong> RB算法仅从数据集全局出发寻找孤立点，会导致孤立点的寻找过程中忽略了数据点所在的类的密集程度对孤立点的影响。<br><a id="more"></a><br>所以，在RB算法基础上，提出了密集度加权的分辨率孤立点挖掘算法（WRB算法）。<br>主要是通过计算每个孤立点相距最近的类的稠密度测度作为分辨率的权重，从全局和局部出发，综合考虑数据点周围的点的个数以及每个孤立点与距离本身最近的类的密集度对比计算每个数据点的孤立程度。</p>
</blockquote>
<p>就病人取药时间，将病人的取药时间看作一个个点，将点的个数及密集程度赋值，将一个病人的取药时间量化成一个值，使用一维格子分布密集度算法对其密集度进行度量，从而排序。最后结合实际，进一步剔除混合度密度算法。</p>
<p>最后,代入模型，RB算法以及WRB算法的交集即为可能用高额处方骗保的病人，而利用混合密度算法得出的孤立程度较大的点，即为可能存在骗保的病人。</p>
<p><strong>数据预处理步骤：</strong></p>
<blockquote>
<ol>
<li><strong>数据清洗：</strong>对于数据缺失项，根据其余各表补充，若无法补充关键则删除该数据。去除前后属性明显矛盾可能是由于记录错误而引起的数据项，如药品单价与费用为负值。</li>
<li><strong>目标数据提取：</strong>以同一账单号为条件，对数据进行条件加和，得到一个个对应一定费用的账单。此外对于每个病人的取药次数与分布也进行了提取。</li>
<li><strong>数据规范化：</strong> 由于给出的费用范围太大，造成计算复杂度大大提高，故将数据属性数据按比例缩放，使之落入一个小的特定区间。</li>
</ol>
</blockquote>
<p><strong>假设：</strong></p>
<blockquote>
<ol>
<li>不考虑科室只有一个人得某种病，导致此数据与儿科中其他数据明显不同，默认为每种病都有几个可用的数据。</li>
<li>不考虑某病人分开多次配药，默认每个病人就配一次或者极少次。即一个处方对应一个账单号。</li>
<li>只考虑费用的总和，某种费用有问题可视为总费用有问题。</li>
<li>不考虑由于特殊情况出现需要过多取药的情况。</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>采用基于分辨率的孤立点算法（RB算法）<br>RB算法：</p>
<blockquote>
<p><strong>优点：</strong> 适用于海量的数据库，无需引入参数<br><strong>缺点：</strong> RB算法仅从数据集全局出发寻找孤立点，会导致孤立点的寻找过程中忽略了数据点所在的类的密集程度对孤立点的影响。<br>]]>
    
    </summary>
    
      <category term="MCM" scheme="http://weirdforce.com/tags/MCM/"/>
    
      <category term="2015深圳杯" scheme="http://weirdforce.com/tags/2015%E6%B7%B1%E5%9C%B3%E6%9D%AF/"/>
    
      <category term="A题" scheme="http://weirdforce.com/tags/A%E9%A2%98/"/>
    
      <category term="MCM" scheme="http://weirdforce.com/categories/MCM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine-Learning]]></title>
    <link href="http://weirdforce.com/2016/04/02/Machine-Learning/"/>
    <id>http://weirdforce.com/2016/04/02/Machine-Learning/</id>
    <published>2016-04-02T04:55:23.000Z</published>
    <updated>2017-04-28T06:38:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Multivariate_Linear_Regression">Multivariate Linear Regression</h2><a id="more"></a>
<ol>
<li><p>Multiple Features<br> 区别于单一特征向量，当存在多个特征向量去描述一个函数时，需要利用到多元特征向量去表示。多元特征向量的表示方法如下：<br> <img src="/images/Multiple_Features.png" alt="Alt text"><br> 多元特征向量所表示的函数如下图所示：<br> <img src="/images/Multiple_Function.png" alt="Alt text"><br> 上式中，可以假设存在一个X0＝1来化简式子，得到下图。<br> <img src="/images/Multiple_Function_1.png" alt="Alt text"></p>
</li>
<li><p>Gradient Descent for Mutiple Variables<br> 构造出多特征线性规划后，我们可以通过梯度下降法对其进行求解，此时要选择代价函数J，使目标变量的真实值和预测值的距离最小，故选择最小二乘为代价函数。如下图<br> <img src="/images/Cost_Function.png" alt="Alt text"><br> 于是得到梯度下降的迭代公式：<br> <img src="/images/Gradient_descent.png" alt="Alt text"><br> 运算，化简得到：<br> <img src="/images/Gradient_descent_1.png" alt="Alt text">   </p>
</li>
<li><p>Feature Scaling<br> 特征缩放：为了使得梯度下降算法在使用的过程中更快收敛，我们在存在多个特征的机器学习的题目中，将各个特征的取值范围缩放到相近的范围，例如:[-1,1]。<br> 通常的，我们有Mean normalization:<br> $$x=\frac{x_i-\mu_i}{max-min}$$<br> 通过特征缩放能使我们的梯度下降算法收敛得更快。</p>
</li>
<li><p>Learning Rate<br> 学习率a:我们可以通过对（代价函数最小值——梯度下降迭代次数）的函数图像进行分析，判断梯度下降算法的学习率a是否准确。<br> (1) 若是这个图像是递增的，说明这个学习率过大。<br> (2) 若是这个图像是递减且收敛缓慢，说明这个学习率过小。<br> (3) 若是这个图像是递减且很快收敛，说明这个学习率合适。<br> (P.S. 一般对学习率的选取可以选择3倍一取或10倍一取。)</p>
</li>
<li><p>Features and Polynomial Regression<br> 在使用多元线性回归的时候，我们应该选取比较合适的模型对数据进行拟合，例如：一元二次函数或一元三次函数。如下图所示：<br> <img src="/images/Polynomial_regression.png" alt="Alt text"></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Multivariate_Linear_Regression">Multivariate Linear Regression</h2>]]>
    
    </summary>
    
      <category term="Machine-Learning" scheme="http://weirdforce.com/tags/Machine-Learning/"/>
    
      <category term="机器学习" scheme="http://weirdforce.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Stanford" scheme="http://weirdforce.com/tags/Stanford/"/>
    
      <category term="Machine-Learning" scheme="http://weirdforce.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015深圳杯数学建模A题笔记(1)]]></title>
    <link href="http://weirdforce.com/2016/03/31/MCM-note-1/"/>
    <id>http://weirdforce.com/2016/03/31/MCM-note-1/</id>
    <published>2016-03-31T04:43:49.000Z</published>
    <updated>2017-04-28T04:51:32.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 辅助学习（有监督）的方法 </strong>：统计回归，神经网络。<br><strong> 非辅助学习（无监督）方法 </strong>：<br><strong> 聚类分析 </strong>：在经典的情况下将不同指标视作等同的，忽略了指标间权重的差异，影响了分类的精度。<br><a id="more"></a><br><strong> 步骤：</strong></p>
<blockquote>
<ol>
<li>引入基于指标权重的欧氏距离，刻画数据之间的相似程度</li>
<li>通过聚类算法将数据按照相似程度不同分成多类，分类中出现的孤立点即为意思欺诈点。 权重指标评价函数CFuzziness(w)<br>该函数刻画随着权重w的改变，分类的模糊程度的变化。</li>
</ol>
</blockquote>
<p><strong> 粒子群优化（MPSO）算法： </strong><br>极小化属性权重评价函数，得到每个指标的权重赋值。将得到的权重应用于聚类算法。</p>
<p><strong> 建立模型过程：</strong></p>
<blockquote>
<ol>
<li>筛选与处理数据，剔除显著无关的指标与无效的交易记录；</li>
<li>构造属性权重评价函数CFuzziness(w),用以描述聚类效果的不确定性，通过粒子群优化算法求得属性权重评价函数取得最小值得最优解w作为各项属性的权重。</li>
<li>构造改进的欧氏距离函数d，用改进的欧式距离作为聚类函数的输入；</li>
<li>应用聚类分析算法，无监督给出样本数据分类，以区分正常医保消费与欺诈记录；</li>
</ol>
</blockquote>
<p><strong> 冗余项忽略： </strong><br>排除身高、性别、所在省份等信息对结果影响</p>
<p><strong> 指标确定： </strong></p>
<blockquote>
<ol>
<li>欺诈行为的主体一定是有医保的患者。故筛选掉无医保患者的取药记录。</li>
<li>两种欺诈类型表现为单张账单价格过高以及拿药次数过于频繁。故将单张账单总价格和单个患者拿药次数应该分别作为判断是否为欺诈的第一项和第二项的指标。</li>
<li>生活经验：部分科室、或者个别医生可能存在不合理开医嘱作为患者取药凭证的现象。故把执行科室以及开嘱医生ID作为影响判断是否欺诈的第三项和第四项指标。</li>
<li>考虑有一种欺诈类型是刷他人的医保卡，可能存在部分人经常将自己的医保卡外借的情况，所以将患者ID作为影响判断是否为欺诈的结果的第五项指标。</li>
</ol>
</blockquote>
<p><strong> 操作过程：</strong></p>
<blockquote>
<ol>
<li>从表格2.1中，导入患者ID和医保手册号－－根据是否有医保手册判断患者是否有医保，筛掉表格2.2中无医保患者的购药记录。</li>
<li>为了得到单张账单的总价以及患者的购药次数，从表格2.2中导入账单号、价格、患者ID＝＝将账单号相同的记录合并，进而计算出单张单据的总价；根据患者ID来统计每位患者的购药次数。</li>
<li>考虑到影响判断是否欺诈的其他因素，将表格2.2执行科室和开嘱医生ID导入Matlab中。</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 辅助学习（有监督）的方法 </strong>：统计回归，神经网络。<br><strong> 非辅助学习（无监督）方法 </strong>：<br><strong> 聚类分析 </strong>：在经典的情况下将不同指标视作等同的，忽略了指标间权重的差异，影响了分类的精度。<br>]]>
    
    </summary>
    
      <category term="MCM" scheme="http://weirdforce.com/tags/MCM/"/>
    
      <category term="2015深圳杯" scheme="http://weirdforce.com/tags/2015%E6%B7%B1%E5%9C%B3%E6%9D%AF/"/>
    
      <category term="A题" scheme="http://weirdforce.com/tags/A%E9%A2%98/"/>
    
      <category term="MCM" scheme="http://weirdforce.com/categories/MCM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Quicksum]]></title>
    <link href="http://weirdforce.com/2016/03/12/Quicksum/"/>
    <id>http://weirdforce.com/2016/03/12/Quicksum/</id>
    <published>2016-03-12T04:37:33.000Z</published>
    <updated>2017-04-28T04:41:31.000Z</updated>
    <content type="html"><![CDATA[<p>这道题十分简单，不过需要注意使用gets函数～</p>
<p><strong> 题目链接:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2734" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a></p>
<p>解题思路：</p>
<blockquote>
<ol>
<li>清楚每个字母的ASCII值，将其值减去64得到1～26。</li>
<li>注意空格占一个位置，所以必须将空格输入。</li>
<li>空格的值为0，在统计的总数中可以进行排除。</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">char</span> str[<span class="number">256</span>]={<span class="number">0</span>};
    <span class="keyword">int</span> total,i;
    <span class="keyword">while</span>(gets(str))
    {
        total=<span class="number">0</span>;
        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'#'</span>)
                <span class="keyword">break</span>;
        <span class="keyword">for</span>(i=<span class="number">0</span>;str[i] !=<span class="string">'\0'</span>;i++)
        {
                 <span class="keyword">if</span>(str[i] != <span class="string">' '</span>)
                     total+=(str[i]-<span class="number">64</span>) * (i+<span class="number">1</span>);
        }
        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,total);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这道题十分简单，不过需要注意使用gets函数～</p>
<p><strong> 题目链接:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2734">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Palindrom Numbers]]></title>
    <link href="http://weirdforce.com/2016/03/12/Palindrom-Numbers/"/>
    <id>http://weirdforce.com/2016/03/12/Palindrom-Numbers/</id>
    <published>2016-03-12T04:28:58.000Z</published>
    <updated>2017-04-28T04:36:06.000Z</updated>
    <content type="html"><![CDATA[<p>这是一道检验回文数的程序（在2～16进制下）～</p>
<p><strong> 题目链接：<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1078" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>思路大致如下：</p>
<blockquote>
<ol>
<li>需要一个字符数组用于记录输入数在某进制下的表示数，然后对其进行头尾回文比较。</li>
<li>需要一个数组记录输入数在哪些进制下存在回文数或它根本不是回文数。</li>
<li>用循环去实现对每个输入数在哪些进制下为回文数的判断</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> n,i,x;
    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)
      {
        x=<span class="number">0</span>;
        <span class="keyword">char</span> s[<span class="number">16</span>]={<span class="number">0</span>};
        <span class="keyword">int</span> b[<span class="number">15</span>]={<span class="number">0</span>};
        <span class="keyword">int</span> j;
        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=<span class="number">16</span>;j++)
        {
        <span class="keyword">int</span> p=n;
        i=<span class="number">0</span>;
        <span class="keyword">while</span>(p)
        {
            s[i]=p%j;
            i++;
            p/=j;
        }
        <span class="keyword">int</span> k;
        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;i/<span class="number">2</span>;k++)
        {
                <span class="keyword">if</span>(s[k]!=s[i-k-<span class="number">1</span>])
                    <span class="keyword">break</span>;
        }
        <span class="keyword">if</span>(k&gt;=i/<span class="number">2</span>)
            b[x++]=j;
        }
        <span class="keyword">if</span>(x==<span class="number">0</span>)
            <span class="built_in">printf</span>(<span class="string">"Number %d is not a palindrom\n"</span>,n);
        <span class="keyword">else</span>
        {
            <span class="built_in">printf</span>(<span class="string">"Number %d is palindrom in basis"</span>,n);
            <span class="keyword">int</span> m;
            <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;x;m++)
                <span class="built_in">printf</span>(<span class="string">" %d"</span>,b[m]);
            <span class="built_in">printf</span>(<span class="string">"\n"</span>);
        }
}
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这是一道检验回文数的程序（在2～16进制下）～</p>
<p><strong> 题目链接：<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1078">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ZOJ" scheme="http://weirdforce.com/tags/ZOJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[I Think I Need a Houseboat]]></title>
    <link href="http://weirdforce.com/2016/03/12/I-Think-I-Need-a-Houseboat/"/>
    <id>http://weirdforce.com/2016/03/12/I-Think-I-Need-a-Houseboat/</id>
    <published>2016-03-12T04:25:33.000Z</published>
    <updated>2017-04-28T04:27:56.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚AC了一道题目，又是一道数学题目～<br><strong> 题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1065" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a></p>
<p>解题思路如下：</p>
<blockquote>
<ol>
<li>因题意可知每年面积增大50平方英里，形状为半圆，可以直接得到半径的平方。</li>
<li>输入的坐标到原点的距离平方为 x的平方+y的平方。</li>
<li>最后将1，2两个数据进行相除就能得到年数。<br>  (Tips: 要注意的是，不足一年按一年计，年数为整数)</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> t,count1;
<span class="keyword">double</span> x,y;
<span class="built_in">cin</span>&gt;&gt;t;
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)
{
    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;
    count1=<span class="built_in">ceil</span>((x*x+y*y)*<span class="number">3.1419</span>/<span class="number">100</span>);
    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Property "</span>&lt;&lt;i&lt;&lt;<span class="string">": This property will begin eroding in year     "</span>&lt;&lt;count1&lt;&lt;<span class="string">"."</span>&lt;&lt;endl;
}
<span class="built_in">cout</span>&lt;&lt;<span class="string">"END OF OUTPUT."</span>&lt;&lt;endl;
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚AC了一道题目，又是一道数学题目～<br><strong> 题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1065">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Financial Management]]></title>
    <link href="http://weirdforce.com/2016/03/12/Financial-Management/"/>
    <id>http://weirdforce.com/2016/03/12/Financial-Management/</id>
    <published>2016-03-12T04:20:28.000Z</published>
    <updated>2017-04-28T04:24:22.000Z</updated>
    <content type="html"><![CDATA[<p>前几天AC的一道简单题目～学到了一些东西～</p>
<p><strong> 题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1064" target="_blank" rel="external">题目</a> </strong></p>
<a id="more"></a>
<p>题目比较简单，思路就是输入十二个月的金额求平均值(保留两位小数，四舍五入)。<br>这题我WA了很多次，原因是：</p>
<blockquote>
<p>1.在C语言中double 类型必须用%lf形式输入，而输出可以为%f。<br>2.不用纠结于题目所给的四舍五入。</p>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> 
</span>{ 
<span class="keyword">double</span> a; 
<span class="keyword">int</span> i; 
<span class="keyword">double</span> count1=<span class="number">0</span>; 
<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++) 
{ 
<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a); 
count1+=a; 
} 
<span class="built_in">printf</span>(<span class="string">"$%.2f\n"</span>, count1/<span class="number">12</span>); 
<span class="keyword">return</span> <span class="number">0</span>; 
} 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>前几天AC的一道简单题目～学到了一些东西～</p>
<p><strong> 题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1064">题目</a> </strong></p>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Color Me Less]]></title>
    <link href="http://weirdforce.com/2016/03/12/Color-Me-Less/"/>
    <id>http://weirdforce.com/2016/03/12/Color-Me-Less/</id>
    <published>2016-03-12T04:13:35.000Z</published>
    <updated>2017-04-28T04:19:05.000Z</updated>
    <content type="html"><![CDATA[<p>又是一道比较简单的题目～</p>
<p><strong> 题目链接: <a href="http://poj.org/problem?id=1046" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>题目思路如下：</p>
<blockquote>
<ol>
<li>输入16组已知RGB，输出余下输入所对应的映射。</li>
<li>映射是由距离公式决定的，那么在已知RGB中找出与输入RGB距离最小的RGB为所求RGB。</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> r[<span class="number">17</span>],g[<span class="number">17</span>],b[<span class="number">17</span>];
<span class="keyword">int</span> s,t,u,num;
<span class="keyword">int</span> min;
<span class="keyword">int</span> d;
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">15</span>;i++)
{
    <span class="built_in">cin</span>&gt;&gt;r[i]&gt;&gt;g[i]&gt;&gt;b[i];
}
<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t&gt;&gt;u &amp;&amp; u!=-<span class="number">1</span> &amp;&amp; s!=-<span class="number">1</span> &amp;&amp; t!=-<span class="number">1</span>)
{
   min=<span class="number">200000</span>;
   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">15</span>;i++)
   {
           d= (s-r[i])*(s-r[i])+(t-g[i])*(t-g[i])+(u-b[i])*(u-b[i]);
           <span class="keyword">if</span>(min &gt; d)
           {
           min = d;
           num = i;
           }
   }
   <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;s&lt;&lt;<span class="string">","</span>&lt;&lt;t&lt;&lt;<span class="string">","</span>&lt;&lt;u&lt;&lt;<span class="string">") maps to ("</span>&lt;&lt;r[num]&lt;&lt;<span class="string">","</span>&lt;&lt;g[num]&lt;&lt;<span class="string">","</span>&lt;&lt;b[num]&lt;&lt;<span class="string">")"</span>&lt;&lt;endl;
}
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>又是一道比较简单的题目～</p>
<p><strong> 题目链接: <a href="http://poj.org/problem?id=1046">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://weirdforce.com/tags/POJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Binary Numbers]]></title>
    <link href="http://weirdforce.com/2016/03/12/Binary-Numbers/"/>
    <id>http://weirdforce.com/2016/03/12/Binary-Numbers/</id>
    <published>2016-03-12T04:08:34.000Z</published>
    <updated>2017-04-28T04:12:20.000Z</updated>
    <content type="html"><![CDATA[<p>这也是一道比较简单的入门题～是算出输入数二进制表示的1的位置</p>
<p><strong> 题目链接:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1390" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>解题思路大致如下:</p>
<blockquote>
<ol>
<li>让输入数对2取余，再让输入数除以2，直到它变为0。</li>
<li>因为题目正好是求倒序的位置所以直接做第一步不用再进行顺序颠倒的工作。</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> t,n,count1,flag;
<span class="built_in">cin</span>&gt;&gt;t;
<span class="keyword">while</span>(t--)
{
<span class="built_in">cin</span>&gt;&gt;n;
flag=<span class="number">1</span>;
count1=<span class="number">0</span>;
<span class="keyword">while</span>(n)
{   
    <span class="keyword">if</span>(n%<span class="number">2</span>)
    {    
        <span class="keyword">if</span>(flag)
            <span class="built_in">cout</span>&lt;&lt;count1;
        <span class="keyword">else</span>
            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;count1;
        flag=<span class="number">0</span>;
    }  
    n=n/<span class="number">2</span>;
    count1++;
}
<span class="built_in">cout</span>&lt;&lt;endl;
}  
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这也是一道比较简单的入门题～是算出输入数二进制表示的1的位置</p>
<p><strong> 题目链接:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1390">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gridland]]></title>
    <link href="http://weirdforce.com/2016/03/11/Gridland/"/>
    <id>http://weirdforce.com/2016/03/11/Gridland/</id>
    <published>2016-03-11T03:54:18.000Z</published>
    <updated>2017-04-28T04:02:27.000Z</updated>
    <content type="html"><![CDATA[<p>今天AC了一道比较有趣的数学题～</p>
<p><strong> 题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1046" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>这道题目是比较简单的一道题目，具体思路如下：</p>
<ol>
<li>找规律，由题目所给的条件自己画多几个图找出画出哈密顿回路的最短路径。</li>
<li>找到规律为：<ul>
<li>若所给的点的数量为偶数，则最短路径就为点的数量。</li>
<li>若所给的点的数量为奇数，则最短路径就为点的数量加上根号2。<br> (Tips: 这里由于题目所给出的输出保留两位小数，可以将根号2直接换成0.41)</li>
</ul>
</li>
</ol>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> 
</span>{ 
    <span class="keyword">int</span> n,m,t,i;
    <span class="keyword">double</span> k; 
    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t); 
    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++) 
    { 
        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m); 
        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n"</span>,i); 
        k=n*m; 
        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span> &amp;&amp; m%<span class="number">2</span>!=<span class="number">0</span>) 
                <span class="built_in">printf</span>(<span class="string">"%.2f\n\n"</span>,k + <span class="number">0.41</span>); 
        <span class="keyword">else</span> 
                <span class="built_in">printf</span>(<span class="string">"%.2f\n\n"</span>,k);
     } 
<span class="keyword">return</span> <span class="number">0</span>;
}    
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>今天AC了一道比较有趣的数学题～</p>
<p><strong> 题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1046">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[今年暑假不AC]]></title>
    <link href="http://weirdforce.com/2016/03/10/jinnianshujiabuAC/"/>
    <id>http://weirdforce.com/2016/03/10/jinnianshujiabuAC/</id>
    <published>2016-03-10T03:44:08.000Z</published>
    <updated>2017-04-28T03:50:50.000Z</updated>
    <content type="html"><![CDATA[<p>好的，今天继续AC了一道比较简单的贪心题目。</p>
<p><strong> 题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2037" target="_blank" rel="external">题目</a></strong><br><a id="more"></a><br>题目的思路大致如下：<br>要使得看尽量多的完整的比赛，必须要使节目结束时间尽量早，且要使得下一个节目的开始时间比上一个节目的开始时间要晚。</p>
<blockquote>
<ol>
<li>先将输入的节目单对其结束时间进行由小到大的排序。</li>
<li>再从排好的节目单由第一个逐步寻找下一个节目开始时间比前一个节目时间晚的节目。并每次更新最后节目的结束时间。在节目单中，从头找到尾。</li>
<li>每次找到新节目将节目计数器不断递增。</li>
<li>输出可完整观看的节目总数。</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> t,count1,s,u,k;
    <span class="keyword">int</span> a[<span class="number">101</span>];
    <span class="keyword">int</span> b[<span class="number">101</span>];
    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t &amp;&amp; t)
    {
    count1=<span class="number">1</span>;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)
    {
        <span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];
    }
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; (t-<span class="number">1</span>);i++)
    {
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; (t-<span class="number">1</span>-i);j++)
        {   
                 <span class="keyword">if</span>(b[j]&gt;b[j+<span class="number">1</span>])
                 {
                     k=b[j+<span class="number">1</span>];
                     b[j+<span class="number">1</span>]=b[j];
                     b[j]=k;
                     k=a[j+<span class="number">1</span>];
                     a[j+<span class="number">1</span>]=a[j];
                     a[j]=k;
                 }    
        }   
    }
    s=a[<span class="number">0</span>];
   u=b[<span class="number">0</span>];
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t;i++)
    {
        <span class="keyword">if</span>(a[i] &gt;= u)
        {
            count1++;
            u=b[i];
        }  
    }
    <span class="built_in">cout</span>&lt;&lt;count1&lt;&lt;endl;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>好的，今天继续AC了一道比较简单的贪心题目。</p>
<p><strong> 题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2037">题目</a></strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Moving Tables]]></title>
    <link href="http://weirdforce.com/2016/03/09/Moving-Tables/"/>
    <id>http://weirdforce.com/2016/03/09/Moving-Tables/</id>
    <published>2016-03-08T16:12:49.000Z</published>
    <updated>2017-04-27T18:24:04.000Z</updated>
    <content type="html"><![CDATA[<p>今天AC了另一道比较有趣的题目～</p>
<p><strong> 题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1050" target="_blank" rel="external">题目</a></strong></p>
<a id="more"></a>
<p>房间结构如下:<br><img src="/images/1050-1.gif" alt="Alt text"></p>
<p>搬桌子规则如下：<br><img src="/images/1050-2.gif" alt="Alt text"></p>
<p>解题思路：<br>首先，可以先仔细地看题，我们可以从题目中看出，这是一个400个房间，奇数号房间和偶数号房间相对，走廊只允许通过一张桌子且将桌子从一间房搬到另一间房间所花的时间为10mins。<br>仔细考虑题目，我们可以知道每两个房间（奇房间和相对应的偶房间）共享一块走廊区域，于是可以很清晰地将400个房间划分为200组。<br>根据题意，我们需要求出最小的搬运时间。这里需要注意的是，我们如果使用了集合区间的包含关系来划分各个房间时，会掉进一个误区。在这里，我们很清楚地知道，无交集的两个集合可以看作是两个房间互不影响。那么是不是只要不断地检测互不影响的组数，将其归为一类，就能知道最短的时间呢？<br>答案是否定的，在这里，我们可以假设，有三张桌子要进行搬运，其中分别为：1号搬到10号，11号搬到13号，14号搬到29号。显然，1-10和11-13互不影响，也同14－29互不影响，而11-13却是和14-29存在影响的。当我们将它们归为一组，那么答案显然不是题目要求的“最短”所需时间。所以这种方法并不理想。（卡了我挺久。。。）<br>因此，我们将搬桌子这个过程进行一定地抽象，可以看作是进行两个组之间地连线。那么，显然，当存在有两条线相交时，他们会相互影响，导致时间增加。那么此问题就可以简化为求出最多有多少条线相交于同一点（即同一块走廊区域）。</p>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">void</span> <span class="title">max1</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span>
</span>{
    <span class="keyword">int</span> k;
    <span class="keyword">if</span> (a&gt;b)
    {
        k=a;
        a=b;
        b=k;
    }
}
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> t,n,flag,s,u,maxx;
    <span class="keyword">int</span> count1;
    <span class="built_in">cin</span>&gt;&gt;t;
    <span class="keyword">while</span>(t--)
    {
    maxx=<span class="number">0</span>;
    <span class="keyword">int</span> x[<span class="number">201</span>]={<span class="number">0</span>};
    <span class="built_in">cin</span>&gt;&gt;n;
    <span class="keyword">while</span>(n--)
    {
        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;u;
        max1(s,u);
        s=(s+<span class="number">1</span>)/<span class="number">2</span>;
        u=(u+<span class="number">1</span>)/<span class="number">2</span>;
        <span class="keyword">for</span>(<span class="keyword">int</span> j=s;j&lt;=u;j++)
                 x[j]++;
    }

    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200</span>;i++)
    {
        <span class="keyword">if</span>(maxx &lt; x[i])
                maxx=x[i];
    }
    count1=<span class="number">10</span>*maxx;
    <span class="built_in">cout</span>&lt;&lt;count1&lt;&lt;endl;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>今天AC了另一道比较有趣的题目～</p>
<p><strong> 题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1050">题目</a></strong></p>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FatMouse' Trade]]></title>
    <link href="http://weirdforce.com/2016/03/07/FatMouse_Trade/"/>
    <id>http://weirdforce.com/2016/03/07/FatMouse_Trade/</id>
    <published>2016-03-06T16:12:49.000Z</published>
    <updated>2017-04-27T17:37:10.000Z</updated>
    <content type="html"><![CDATA[<p>今天重新翻出了HDU的ACM Steps中的题目做了一下，发现一道比较简单的题目。</p>
<p><strong> 题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1009" target="_blank" rel="external">题目</a></strong></p>
<a id="more"></a>
<p>题目的思路大致可以分为两个部分：</p>
<p>第一部分：将每个房间中JavaBeans和cat food的比例（精确到小数点后三位）分别求出来并存在一个数组之中，并将这个数组进行从大到小的排序。</p>
<p>第二部分：对排序好的数组从大到小，依次累加其对应的JavaBeans的数量直至cat food不足以付出一个房间的cat food要求，再用之前的比例进行计算，统计所得到的所有JavaBeans的数量。</p>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="keyword">struct</span> c{
    <span class="keyword">int</span> j;
<span class="keyword">int</span> u;
<span class="keyword">double</span> k;
    };
    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">struct</span> c *a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>
</span>{
    <span class="keyword">if</span>(left &gt;= right)
        <span class="keyword">return</span>;
    <span class="keyword">int</span> x = left;
    <span class="keyword">int</span> y = right;
    <span class="keyword">double</span> key = a[left].k;
    <span class="keyword">double</span> key1 = a[left].j;
    <span class="keyword">double</span> key2 = a[left].u;

    <span class="keyword">while</span>(x&lt;y)
    {
        <span class="keyword">while</span>(x&lt;y &amp;&amp; key &lt;= a[y].k)
        {
            y--;
        }

        a[x].j=a[y].j;
           a[x].u=a[y].u;
        a[x].k=a[y].k;

        <span class="keyword">while</span>(x&lt;y &amp;&amp; key &gt;=a[x].k)
        {
            x++;
        }   

        a[y].j=a[x].j;
        a[y].u=a[x].u;
        a[y].k=a[x].k;
    }

    a[x].j = key1;
    a[x].u = key2;
    a[x].k = key;
    sort(a, left, x - <span class="number">1</span>);
    sort(a, x+<span class="number">1</span>, right);

}

<span class="keyword">struct</span> c f[<span class="number">1000</span>];
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> m,n,i;
    <span class="keyword">int</span> a,b;
    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n)!=EOF &amp;&amp; m!=-<span class="number">1</span> &amp;&amp; n!=-<span class="number">1</span>)
    {
        <span class="keyword">double</span> count=<span class="number">0</span>;
        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)
        {
        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);
        f[i].j=a;
        f[i].u=b;
        f[i].k=(<span class="keyword">double</span>)a/b;
        }
        sort(f,<span class="number">1</span>,n);
        <span class="keyword">for</span>(i=n;i&gt;=<span class="number">1</span>;i--)
        {
            <span class="keyword">if</span>(m &gt;= f[i].u)
                count+=f[i].j;
            <span class="keyword">else</span>
            {    
                count=count+f[i].k*m;
                <span class="keyword">break</span>;
            }
            m-=f[i].u;
        }
        <span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>, count);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>仔细想想，应该还有更简便的方法，期待下次能更新～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天重新翻出了HDU的ACM Steps中的题目做了一下，发现一道比较简单的题目。</p>
<p><strong> 题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1009">题目</a></strong></p>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gale-Shapley算法]]></title>
    <link href="http://weirdforce.com/2016/03/02/Gale-Shapley/"/>
    <id>http://weirdforce.com/2016/03/02/Gale-Shapley/</id>
    <published>2016-03-02T03:39:38.000Z</published>
    <updated>2017-04-27T15:32:57.000Z</updated>
    <content type="html"><![CDATA[<p>今天的算法设计与分析课程讲到了一个非常有趣的问题，于是拿来博客分享一下。<br>首先，先来介绍一下稳定婚姻问题。<br><a id="more"></a></p>
<p><strong> “稳定婚姻问题”在生活中是一个典型的问题，通俗地可叙述为：当前有n位男生和n位女生最后要组成稳定的婚姻家庭。在过程的开始之前，男生和女生在各自的心目中都按照喜爱程度对n位异性有了各自的排序，然后他们开始选择自己的对象。问如何组合才能使得他们之间得婚姻是稳定的。</strong></p>
<p>这个问题刚刚拿出来看可能让人一头雾水，怎么匹配他们才算稳定啊？不稳定的定义又是什么呢？<br>于是问题来到了解决稳定的定义上，通过题目很容易看出，每个男生和女生对异性都有一个排序，而稳定的前提就建立在这排序上。通过分析，我们很容易看出，当一对男女在对方的排序上都是第一，但他们却不能在一起，将就地和另一个伴侣在一起时，那么他们的婚姻就是不稳定的。<br>那么要怎么配对才会使得所有的婚姻都是稳定的呢？<br>可能很多人会想到一种策略：那就是先通过一种不稳定的配对方式，再不断地去修改这种配对方式使得所有人的婚姻都是稳定的。例如有一对想私奔（即不稳定）的情侣，则按他们的愿望进行情侣对换，直到最终消除所有的不稳定组合。这种方法虽然有一定程度上能满足稳定性，但这种策略的局限在于它不一定存在一个“最终结果”。因为有可能这种对换会不停持续下去，形成一个死循环，无法确定一个完整的方案。<br>那么，到底应该如何进行配对呢？<br>这里，我们来介绍一个算法，叫Gale-Shapley算法。<br>1962年，美国数学家David Gale和Lloyd Shapley发明了一种寻找稳定婚姻的策略，人们称之为延迟认可算法（Gale-Shapley算法）。<br>先对所有男生进行落选标记，称其为自由男。当存在自由男时，进行以下操作：</p>
<blockquote>
<ol>
<li>每一位自由男在所有尚未拒绝她的女士中选择一位被他排名最优先的女士；</li>
<li>每一位女士将正在追求她的自由男与其当前男友进行比较，选择其中排名优先的男士作为其男友，即若自由男优于当前男友，则抛弃前男友；否则保留其男友，拒绝自由男。</li>
<li>若某男士被其女友抛弃，重新变成自由男。</li>
</ol>
</blockquote>
<p>这样重复上述过程有限轮后，有些男生已经有女朋友了，然而有些仍然是单身。再继续这个过程下去，直到某个时候所有人都不再是单身，下一轮也就不会有任何追求产生，这个配对算法也就自动结束了。此时的婚姻匹配就一定是稳定的了。<br>那么如何说明这个配对算法是可以终止的呢？<br>随着轮数的不断重复，总有一个时候所有人都能配对上。倘若整个流程一直没有因所有人配上对而结束，那么必然会有一个男生追遍了所有女生。而女生只要被人追过，就不可能是单身。既然所有女生都被这个男生追过，就说明所有女生都已不是单身，也就说明所有人都已配对了。<br>接下来，我们再来证明这种配对方案是稳定的。<br>首先，我们可以看出，男生所追求的对象总是越来越差（对于自身排名），而一个女生的男友却只可能越来越好。假设有一个男1和女1各自有自己的对象，比起现在的对象来说，男1更喜欢女1。那么男1之前一定跟女1表白过。既然女1并没有跟男1在一起，说明了女1有了比男1更好的男生。这从侧面证明了两人虽然不是一对，但都觉得对方比自己现在的对象好的情况绝不可能发生。<br>这个算法有趣的地方就在于它是以一种游戏的形式来解决问题的。这个算法应用领域十分广泛，因为它能有效地解决很多生活中关于稳定匹配的问题。它还曾经因解决过经济市场中稳定匹配的问题获得过2012年诺贝尔经济学奖。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天的算法设计与分析课程讲到了一个非常有趣的问题，于是拿来博客分享一下。<br>首先，先来介绍一下稳定婚姻问题。<br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="婚配问题" scheme="http://weirdforce.com/tags/%E5%A9%9A%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    
      <category term="Algorithm" scheme="http://weirdforce.com/categories/Algorithm/"/>
    
  </entry>
  
</feed>
