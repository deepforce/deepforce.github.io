<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Zack's Park]]></title>
  <subtitle><![CDATA[Welcome to weirdland！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://weirdforce.com/"/>
  <updated>2017-05-25T08:57:06.000Z</updated>
  <id>http://weirdforce.com/</id>
  
  <author>
    <name><![CDATA[Zack]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Machine Learning课程笔记(6)]]></title>
    <link href="http://weirdforce.com/2017/05/21/Machine-Learning-note-6/"/>
    <id>http://weirdforce.com/2017/05/21/Machine-Learning-note-6/</id>
    <published>2017-05-21T12:59:57.000Z</published>
    <updated>2017-05-25T08:57:06.000Z</updated>
    <content type="html"><![CDATA[<p>本篇将总结逻辑回归(Logistic Regression)的相关内容。<br><a id="more"></a></p>
<h2 id="逻辑回归(Logistic_Regression)">逻辑回归(Logistic Regression)</h2><p><strong>逻辑回归:</strong>指的是将数据分类，使之得到离散的结果的方法。例如，我们能够使用逻辑回归对电子邮件进行分类，用以区分垃圾邮件和非垃圾邮件。</p>
<h3 id="分类(Classification)">分类(Classification)</h3><p><strong>定义：</strong>我们通过尝试预测一个结果是否属于某一个类。例如，正确或者错误。下面是一些分类问题的例子。<br><img src="/images/classification_ex.png" alt="Alt text"></p>
<p><strong>注意：</strong>逻辑回归算法的输出值永远在0到1之间。</p>
<h3 id="假说表示(Hypothesis_Representation)">假说表示(Hypothesis Representation)</h3><p>逻辑回归中，模型的输出需要满足变量范围在0和1之间。假设函数的表达式如下：<br>$$h_{\theta}(x) = g(\theta^{T}X)$$<br>其中，X代表了特征向量。<br>g代表了逻辑函数(logistic function),常用的逻辑函数是一个S形函数(Sigmoid function),公式为$g(z) = \frac{1}{1+e^{-z}}$。图像如下:<br><img src="/images/sigmoid_function.png" alt="Alt text"></p>
<p>综上，表达式为：$h_{\theta}(x) = \frac{1}{1+e^{-\theta^TX}}$<br>它的作用是：<br><strong>对于给定的输入变量，根据选择的参数计算输出变量等于1的可能性(estimated probablity),即</strong>$h_{\theta} = P(y=1|x;\theta)$。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇将总结逻辑回归(Logistic Regression)的相关内容。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/tags/Machine-Learning/"/>
    
      <category term="机器学习" scheme="http://weirdforce.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine Learning课程笔记(5)]]></title>
    <link href="http://weirdforce.com/2017/05/16/Machine-Learning-note-5/"/>
    <id>http://weirdforce.com/2017/05/16/Machine-Learning-note-5/</id>
    <published>2017-05-16T02:37:02.000Z</published>
    <updated>2017-05-21T12:59:40.000Z</updated>
    <content type="html"><![CDATA[<p>本篇总结正规方程的相关知识。<br><a id="more"></a></p>
<h2 id="正规方程(Normal_Equation)">正规方程(Normal Equation)</h2><p><strong>正规方程：</strong>区别于梯度下降算法，是另一种解决线性回归问题的算法。是通过求解下面方程来找出使得代价函数最小的参数的：<br>$$\frac{\partial}{\partial\theta_j}J(\theta_j)$$</p>
<p>首先先介绍一些规范：</p>
<blockquote>
<ol>
<li>训练集特征矩阵为X（包含了$X_0=1$）。</li>
<li>训练集结果为向量y。</li>
</ol>
</blockquote>
<p>则正规方程求解后得到的向量为：<br>$$\theta = (X^TX)^{-1}X^Ty$$</p>
<p>举下列数据为例：<br><img src="\images\ne_problem.png" alt="Alt text"><br>即<br><img src="\images\ne_problem_1.png" alt="Alt text"><br>运用正规方程求解参数可得：<br><img src="\images\ne_answer.png" alt="Alt text"></p>
<p><strong>注意：对于不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用的。</strong></p>
<p><strong>梯度下降和正规方程的对比：</strong><br><img src="/images/gradient_normal_compare.png" alt="Alt text"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇总结正规方程的相关知识。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/tags/Machine-Learning/"/>
    
      <category term="机器学习" scheme="http://weirdforce.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine-Learning课程笔记(4)]]></title>
    <link href="http://weirdforce.com/2017/05/15/Machine-Learning-note-4/"/>
    <id>http://weirdforce.com/2017/05/15/Machine-Learning-note-4/</id>
    <published>2017-05-15T04:55:23.000Z</published>
    <updated>2017-05-15T12:18:26.000Z</updated>
    <content type="html"><![CDATA[<p>本篇将总结监督学习中的线性回归中的多变量线性回归。<br><a id="more"></a></p>
<h2 id="多变量线性回归(Linear_Regression_with_Multiple_Variables)">多变量线性回归(Linear Regression with Multiple Variables)</h2><h3 id="多维特征(Multiple_Features)">多维特征(Multiple Features)</h3><p><strong>定义:</strong>区别于单一特征向量，当存在多个特征向量去描述一个函数时，需要利用到多元特征向量去表示。多元特征向量的表示方法如下：<br><img src="/images/Multiple_Features.png" alt="Alt text"><br>多元特征向量所表示的函数如下图所示：<br><img src="/images/Multiple_Function.png" alt="Alt text"><br>上式中，可以假设存在一个X0＝1来化简式子，得到下图。<br><img src="/images/Multiple_Function_1.png" alt="Alt text"></p>
<h3 id="多变量梯度下降(Gradient_Descent_for_Mutiple_Variables)">多变量梯度下降(Gradient Descent for Mutiple Variables)</h3><p><strong>原理：</strong>构造出多特征线性规划后，我们可以通过梯度下降法对其进行求解，此时要选择代价函数J，使目标变量的真实值和预测值的距离最小，故选择最小二乘为代价函数。如下图<br><img src="/images/Cost_Function.png" alt="Alt text"><br>于是得到梯度下降的迭代公式：<br><img src="/images/Gradient_descent.png" alt="Alt text"><br>运算，化简得到：<br><img src="/images/Gradient_descent_1.png" alt="Alt text">   </p>
<h3 id="特征缩放(Feature_Scaling)">特征缩放(Feature Scaling)</h3><p><strong>特征缩放：</strong>为了使得梯度下降算法在使用的过程中更快收敛，我们在存在多个特征的机器学习的题目中，将各个特征的取值范围缩放到相近的范围，例如:[-1,1]。如图。<br><img src="/images/Feature_scaling.png" alt="Alt text"><br>通常的，我们有Mean normalization:<br>$$x=\frac{x_i-\mu_i}{max-min}$$<br>通过特征缩放能使我们的梯度下降算法收敛得更快。</p>
<h3 id="学习率(Learning_Rate)">学习率(Learning Rate)</h3><p><strong>学习率a:</strong>我们可以通过对（代价函数最小值——梯度下降迭代次数）的函数图像进行分析，判断梯度下降算法的学习率a是否准确。如下图。<br><img src="/images/Learning_rate_mult.png" alt="Alt text"></p>
<blockquote>
<p>(1) 若是这个图像是递增的，说明这个学习率过大。<br>(2) 若是这个图像是递减且收敛缓慢，说明这个学习率过小。<br>(3) 若是这个图像是递减且很快收敛，说明这个学习率合适。<br>  (P.S. 一般对学习率的选取可以选择3倍一取或10倍一取。)</p>
</blockquote>
<h3 id="特征和多项式回归(Features_and_Polynomial_Regression)">特征和多项式回归(Features and Polynomial Regression)</h3><p><strong>定义：</strong>在使用多元线性回归的时候，我们应该选取比较合适的模型对数据进行拟合，例如：一元二次函数或一元三次函数。如下图所示：<br><img src="/images/Polynomial_regression.png" alt="Alt text"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇将总结监督学习中的线性回归中的多变量线性回归。<br>]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://weirdforce.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine-Learning" scheme="http://weirdforce.com/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode#8 String to Integer (atoi)]]></title>
    <link href="http://weirdforce.com/2017/05/12/leetcode-8-String-to-Integer-atoi/"/>
    <id>http://weirdforce.com/2017/05/12/leetcode-8-String-to-Integer-atoi/</id>
    <published>2017-05-12T11:18:38.000Z</published>
    <updated>2017-05-14T14:16:08.000Z</updated>
    <content type="html"><![CDATA[<p>今天刷了LeetCode的一道题。这题看上起很简单，但实现起来的逻辑比较复杂。<br><a id="more"></a></p>
<p><strong>题目要求：</strong></p>
<blockquote>
<ol>
<li>输入一个字符序列，在这个序列中寻找第一个不为空格的字符。从这个字符开始，读入一个可选的正负号，然后读入一串数字，将这些字符转换成一个数值。</li>
<li>字符串中能够包含额外的字符跟在形成数值的字符后面，这些字符需要被忽略并且不影响这个函数的效果。</li>
<li>如果遇到的第一个不为空格的字符不是一个有效的数字或者并不存在这样的一个字符序列可以转换为数值，则不必进行转换。（因为有可能<strong>字符串为空</strong>或者<strong>字符串只包含空格</strong>）。 </li>
<li>如果转换没有进行，则返回零值。如果转换后的数值超过了int的表示范围，则返回int范围的临界值INT_MAX (2147483647)和INT_MIN (-2147483648)。</li>
</ol>
</blockquote>
<p><strong>思路：</strong></p>
<ol>
<li>C++中的string类型里，存在着find_first_not_of这个函数，它能帮助我们找到第一个不为某个字符的位置。</li>
<li>找到这个位置后，后面判断是否存在着正负号。用一个标记来表示符号的情况。</li>
<li>然后对字符串中的数字字符进行处理，直到碰到非数字字符为止，把处理得到的数值储存起来。</li>
<li>对于没有转换的字符串返回0。对于超出int范围的值应该返回临界值。</li>
</ol>
<p><strong>代码如下：</strong></p>
<pre><code>class <span class="type">Solution</span> {
public:
    <span class="type">int</span> myAtoi(<span class="type">string</span> str) {
        long <span class="literal">result</span> = <span class="number">0</span>;
        <span class="type">int</span> flag = <span class="number">1</span>;
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.length();) {
                i = str.find_first_not_of(' ');
                <span class="keyword">if</span> (str[i] == '-' || str[i] == '+')
                    flag = (str[i++] == '-') ? -<span class="number">1</span> : <span class="number">1</span>;
                <span class="keyword">while</span>(str[i] &lt;= '<span class="number">9</span>' &amp;&amp; str[i] &gt;= '<span class="number">0</span>') {
                    cout &lt;&lt; str[i] &lt;&lt; endl;
                    <span class="literal">result</span> = <span class="literal">result</span> * <span class="number">10</span> + (str[i++] - '<span class="number">0</span>');
                    cout &lt;&lt; <span class="literal">result</span> &lt;&lt;endl;
                    <span class="keyword">if</span> (<span class="literal">result</span> * flag &gt;= <span class="type">INT_MAX</span>)
                        <span class="keyword">return</span> <span class="type">INT_MAX</span>;
                    <span class="keyword">if</span> (<span class="literal">result</span> * flag &lt;= <span class="type">INT_MIN</span>) 
                        <span class="keyword">return</span> <span class="type">INT_MIN</span>;
                }
                <span class="keyword">return</span> <span class="literal">result</span> * flag;
        }
        <span class="keyword">return</span> <span class="number">0</span>;
    }
};
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>今天刷了LeetCode的一道题。这题看上起很简单，但实现起来的逻辑比较复杂。<br>]]>
    
    </summary>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://weirdforce.com/tags/LeetCode/"/>
    
      <category term="Algorithm" scheme="http://weirdforce.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="http://weirdforce.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine Learning课程笔记(3)]]></title>
    <link href="http://weirdforce.com/2017/05/08/Machine-Learning-note-3/"/>
    <id>http://weirdforce.com/2017/05/08/Machine-Learning-note-3/</id>
    <published>2017-05-08T08:13:02.000Z</published>
    <updated>2017-05-15T11:57:23.000Z</updated>
    <content type="html"><![CDATA[<p>本篇将总结监督学习中的线性回归的单变量线性回归。<br><a id="more"></a></p>
<h2 id="单变量的线性回归(Linear_Regression_with_One_Variable)">单变量的线性回归(Linear Regression with One Variable)</h2><p>其中，这里将讲解<strong>单变量的线性回归(Linear Regression with One Variable)</strong>。<br>首先，我们来看回之前总结过的预测房价的例子。见下图。<br><img src="/images/house_price.png" alt="Alt text"><br>如图中所说，这里被归为<strong>监督学习</strong>的原因是，我们对每个数据都给出了“正确的答案”。而称为<strong>回归问题</strong>是因为我们能够根据之前的数据预测出一个准确的输出值，即房屋价格。<br>一般来说，在监督学习中，我们有一个数据集，这个数据集被称为<strong>训练集</strong>。以预测房价为例，见下图。<br><img src="/images/house_train.png" alt="Alt text"></p>
<p>在回归问题中，我们对一些描述的标记如下所示：</p>
<blockquote>
<p>m 代表训练集中实例的数量。<br>x 代表特征／输入变量<br>y 代表目标变量／输出变量<br>(x,y) 代表训练集中的实例<br>($x^{i}$,$y^{i}$) 代表第 i 个观察实例<br>h 代表学习算法的解决方案或函数也称为假设（hypothesis)</p>
</blockquote>
<h3 id="模型表示(Model_Representation)">模型表示(Model Representation)</h3><p><img src="/images/model.png" alt="Alt text"><br>上图描述了一个监督学习算法的工作方式。同样举房屋例子来说，我们通过将训练集（即房屋价格及它们所对应的特征数据）作为输入投入学习算法中，学习算法工作后，会输出一个函数，记作h(即上文代表的hypothesis)。得到h之后，我们可以通过输入房屋的特征数据（即x值），输出房屋的价格（即y值）。因此，我们可以看出h实则是一个从x到y的映射。</p>
<p>h的表示：<br><strong>一般来说，在单变量线性回归问题当中，我们将h表示为：</strong><br>$$h_{\theta}(x)=\theta_0+\theta_1x$$</p>
<h3 id="代价函数(Cost_Function)">代价函数(Cost Function)</h3><p>上面提到了我们用来预测的函数是$h_{\theta}(x)=\theta_0+\theta_1x$的形式。其中$\theta_0$和$\theta_1$是这个模型的<strong>参数</strong>。在这里分别为直线的斜率和在y轴上的截距。我们需要做的便是要为这个模型选择合适的参数，把直线和数据尽可能地相拟合起来。如下图所示。<br><img src="/images/Cost_function_1.png" alt="Alt text"></p>
<p>这时，我们需要引入一个评估指标来衡量我们得到的直线预测得到的值和我们的训练集数据真实值之间的差距：<strong>建模误差(modeling error)</strong>。<br><img src="/images/modeling_error.png" alt="Alt text"></p>
<p>如上图所示，当我们通过将各个数据中的建模误差的平方求和之后，就能构建<strong>代价函数</strong>:<br>$$J(\theta_0, \theta_1)=\frac{1}{2m} \sum_{i=1}^m(h_{\theta}(x^{(i)})-y^{(i)})^2$$</p>
<p>得到代价函数之后，我们的目标就转为了找到$\theta_0$和$\theta_1$的取值能够使得代价函数取到最小。如下图所示。<br><img src="/images/cost_function_2.png" alt="Alt text"></p>
<p>我们还可以通过等高线图来进行分析：<br><img src="/images/min_cost_function.png" alt="Alt text"><br>可以看出，在三维空间里，存在着使得$J(\theta_0,\theta_1)$最小的点。</p>
<p><strong>一般来说，代价函数被称为平方误差函数。对于回归问题，是常用的合理的选择。</strong></p>
<h3 id="梯度下降(Gradient_Descent)">梯度下降(Gradient Descent)</h3><p><strong>梯度下降</strong>指的是一个用来求函数最小值的算法。我们可以使用它求出代价函数$J(\theta_0,\theta_1)$的最小值。</p>
<p><strong>原理：</strong>通过一开始随机选择的参数组合($\theta_0,\theta_1,…,\theta_n$),计算代价函数，然后在这个过程中寻找下一个能让代价函数值下降最多的参数组合，直到找到一个<strong>局部最小值(local minimum)</strong>。当然，因为并没有将所有的参数组合全部尝试，所以我们不能确定的到的局部最小值就是全局最小值，而选择不同的初始参数组合，可能会找到不同的局部最小值。如下图所示。<br><img src="/images/gradient_descent_theory.png" alt="Alt text"></p>
<p><strong>算法公式：</strong><br><strong>repeat until convergence</strong> <strong>{</strong><br>    $$\theta_j:=\theta_j - \alpha \frac{\partial}{\partial\theta_j}J(\theta)$$<br><strong>}</strong></p>
<p>其中，<strong>$\alpha$是学习率(learning rate)</strong>，决定了沿着能让代价函数下降程度最大方向的每一个迭代的步伐有多大。</p>
<p><strong>注意事项：</strong> 在梯度下降算法当中，我们需要更新参数值。而更新的过程必须要做到同时更新所有的参数项。例如，在单变量线性回归问题中我们需要同时更新$\theta_0$和$\theta_1$。如下图所示。<br><img src="/images/update_gradient.png" alt="Alt text"></p>
<h3 id="学习率(Learning_Rate)">学习率(Learning Rate)</h3><p>上面已经提及了学习率的基本概念，下面对学习率$\alpha$的相关知识进行解释。<br>首先$\alpha$的大小是可以调整的，通过调整$\alpha$的值，可以加快算法的运算，减少运算时间。但$\alpha$的值过大和过小会导致一些问题。<br><strong>$\alpha$过大</strong>：会使得梯度下降的算法有可能一下子越过最低点，甚至可能导致无法收敛。<br><strong>$\alpha$过小</strong>：会导致算法的运算时间过长，效率过低。</p>
<p>在梯度下降算法当中，$\alpha$的值没有必要减小，因为我们在每次迭代对梯度下降算法的参数$\theta$进行更新时，已经在原来的基础中将其更新幅度减小了，这样能够使得我们的算法收敛到我们想要的局部最小值。如下图。</p>
<p><img src="/images/no_need_decrease.png" alt="Alt text"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇将总结监督学习中的线性回归的单变量线性回归。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/tags/Machine-Learning/"/>
    
      <category term="机器学习" scheme="http://weirdforce.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine-Learning课程笔记(2)]]></title>
    <link href="http://weirdforce.com/2017/05/05/Machine-Learning-note-2/"/>
    <id>http://weirdforce.com/2017/05/05/Machine-Learning-note-2/</id>
    <published>2017-05-05T11:12:11.000Z</published>
    <updated>2017-05-06T15:47:54.000Z</updated>
    <content type="html"><![CDATA[<p>本篇总结监督学习和无监督学习。<br><a id="more"></a></p>
<h3 id="监督学习是什么？">监督学习是什么？</h3><p><strong>监督学习指的是我们获得一个数据集，看作输入，同时我们知道正确的答案，看作输出。认为输入和输出之间存在一定的关系。</strong><br>监督学习被分成了两类问题：</p>
<blockquote>
<ol>
<li><strong>回归问题(Regression)</strong></li>
<li><strong>分类问题(Classification)</strong></li>
</ol>
</blockquote>
<p><strong>回归问题</strong>：在回归问题中，我们试着在一段连续的输出中预测结果。即意味着我们试着将输入变量映射到某些连续函数上。如：预测房价（如下图）。<br><img src="/images/predict_house_price.png" alt="Alt text"><br>在房价这个例子中，我们给了一系列房子的数据，给定了数据集中每个样本的正确价格，即它们的实际售价来运用学习算法，算出更多的答案，这些答案落在一个连续的区间上，所以看作是回归问题。可以看到图中，我们采用<strong>直线</strong>和二次方程的<strong>曲线</strong>来拟合数据。在这个过程中，我们采用了不同的学习算法，当然有一个会显得更加合理，我们先不在此做深入讨论。  </p>
<p><strong>分类问题</strong>：在分类问题中，我们试着在一些离散的输出中来预测结果。换句话说，我们试着将输入变量映射到离散的分类里。如：推测乳腺肿瘤良性与否（如下图）<br><img src="/images/breast_cancer.png" alt="Alt text"><br>在推测乳腺肿瘤良性与否的例子中，我们给出了肿瘤的大小（横轴）和它们所对应是否为良性的正确答案（纵轴），用以运用学习算法来算出更多的答案，这些答案会落在两个分类里，分别表示恶性肿瘤和良性肿瘤。可以看到图中分类一共只有两类，但在实际中，分类问题的输出可能并不只有两个值。比如说存在着三种乳腺癌，因为我们希望分成三类，所以我们的预测值就会达到三个。</p>
<p>综上所述，回归问题和分类问题的主要区别在与输出是连续还是离散。而监督学习中是通过一组样本及它们所对应的“正确答案”来对数据进行映射处理，从而对数据进行预测得到一段连续或是离散的输出。</p>
<h3 id="无监督学习是什么?">无监督学习是什么?</h3><p><strong>无监督学习中指的是我们获得一个数据集，看作输入，但我们不知道如何操作数据集，无监督学习的本质是在数据中寻找一些结构。</strong><br>其中无监督学习主要分为了以下问题：</p>
<blockquote>
<ol>
<li><strong>聚类问题</strong></li>
<li><strong>鸡尾酒宴问题</strong></li>
</ol>
</blockquote>
<p><strong>聚类问题</strong>：在没有告知算法标签信息的情况下，通过自动地寻找数据集中的结构，让数据自动地聚类到某些类别当中。如：谷歌新闻、基因聚类（如下图）等。<br><img src="/images/Genes.png" alt="Alt text"><br>在基因聚类这个例子中，输入是一组不同的个体，我们通过对个体在基因层面上数据的分析即是否表达了某些特定的基因，运行聚类算法，将个体聚类到不同的类别当中。  </p>
<p><strong>鸡尾酒宴问题</strong>：在宴会房间中，将声音重叠的数据作为输入，运行无监督学习算法，寻找其中的结构，将各种声音相互剥离开来。（如下图）<br><img src="/images/Cocktail_party.png" alt="Alt text"><br>这个例子中是通过了放置两个麦克风，离说话人的距离不同的每个麦克风记录下不同的声音。虽然是同样的说话的两个说话人，听起来像是两份录音被叠加在一起。但算法还是会区分出两个音源。（详细可看维基百科<strong><a href="https://en.wikipedia.org/wiki/Cocktail_party_effect" target="_blank" rel="external">Cocktail party effect</a></strong>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇总结监督学习和无监督学习。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/tags/Machine-Learning/"/>
    
      <category term="机器学习" scheme="http://weirdforce.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine Learning课程笔记(1)]]></title>
    <link href="http://weirdforce.com/2017/05/05/Machine-Learning-note-1/"/>
    <id>http://weirdforce.com/2017/05/05/Machine-Learning-note-1/</id>
    <published>2017-05-05T08:54:05.000Z</published>
    <updated>2017-05-05T09:23:16.000Z</updated>
    <content type="html"><![CDATA[<p>Coursera上机器学习课程的一些总结和笔记将会一一记录在此博客中。<br><a id="more"></a></p>
<h3 id="机器学习是什么？">机器学习是什么？</h3><p>第一个机器学习的定义来自于Arthur Samuel。他定义机器学习为<strong>在没有特定编程的情况下，给予计算机学习能力的一项研究领域。</strong><br>而CMU的Tom Mitchell给出的定义更加现代化的定义：<br><strong>一个计算机程序被认为能从关于某些类别的任务T和性能度量P学习经验E。如果它在任务T中的性能能被度量为P时，它能随着经验E增加而提高。</strong>  </p>
<p>例如：玩跳棋  </p>
<blockquote>
<p>E = 玩足够多局跳棋的经验<br>T = 玩跳棋这项任务<br>P = 程序赢得下一局跳棋的概率  </p>
</blockquote>
<p>总之，机器学习主要会被分为两种类型：监督学习(Supervised Learning)和无监督学习(Unsupervised Learning)。这两种定义简单可以理解为前者是教计算机如何去完成任务，后者则是让计算机自己学习着去完成任务。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Coursera上机器学习课程的一些总结和笔记将会一一记录在此博客中。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/tags/Machine-Learning/"/>
    
      <category term="机器学习" scheme="http://weirdforce.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Machine Learning" scheme="http://weirdforce.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译原理之词法分析]]></title>
    <link href="http://weirdforce.com/2017/05/04/Compile/"/>
    <id>http://weirdforce.com/2017/05/04/Compile/</id>
    <published>2017-05-04T09:31:35.000Z</published>
    <updated>2017-05-05T08:16:32.000Z</updated>
    <content type="html"><![CDATA[<p>编译原理中的词法分析作业真的是折磨死我了。熬夜弄了一个不完美的版本。在此总结一下。<br><a id="more"></a><br>首先，我们要清楚地了解到整个程序的逻辑过程为如下几个过程：</p>
<blockquote>
<ol>
<li>正则表达式转换NFA</li>
<li>NFA转换DFA</li>
<li>DFA简化为最小化DFA</li>
<li>使用最小化DFA构建词法分析程序</li>
</ol>
</blockquote>
<p>很好，我们清晰地了解到这几个步骤之后，我们先来看<strong>正则表达式转换NFA</strong>。<br>思路如下：<br>要对输入的正则表达式进行分析，就如同之前学过的通过构建算术表达式的后缀表达式一样，我们需要通过区分正则表达式中<strong>符号</strong>及<strong>非符号</strong>，对正则表达式中符号的<strong>优先级</strong>进行先后的处理，这时，我们可以简单地想到使用栈来对符号和非符号进行存储。于是，得出一下结论：<br>数据结构：符号栈，NFA栈<br>然后，让我们进一步对非符号和符号进行分析：<br>非符号：这个很好分析，所有字母和$\epsilon$及$\varnothing$我们看作是最基本的NFA结构。可以构造如下：<br><img src="/images/basis.jpg" alt="Alt text"><br>符号：复杂的正则表达式拥有很多不同的运算符号，这里我们只对最基本的几种符号进行分析处理。<br>如：  </p>
<blockquote>
<p>“(“,左括号;<br>“)”,右括号;<br>“*“,重复符号;<br>“|”,选择符号;<br>“.”,连接符号; (P.S: 此符号一般不出现在正则表达式里，但我们在构建NFA的时候要进行判断是否存在连接运算并添加处理)</p>
</blockquote>
<p>下面来详细说明一下各符号的处理：<br>“(“, 左括号。最简单，只需压入符号栈即可。<br>“)”, 右括号。不需要压入符号栈，但遇到后需要弹出所有在”(“后面压入的运算符号，并进行运算。<br>“*“,重复符号。不需要压入符号栈，且在运算符号里的优先级最高。所以遇到后可以直接弹出NFA进行运算，再把运算得出的结果压入NFA栈里。<br>“|”,选择符号。优先级不如连接符号高，在遇到后，需要先将符号栈内比它优先级更高的符号弹出运算。注意，左括号不弹出，即遇到左括号弹出终止。所以这里需要将连接符号和选择符号（从左到右运算，所以优先级也比此符号高）弹出运算后，再将此符号压入符号栈。<br>“.”,连接符号。由于正则表达式中不会真正出现连接符号，所以我们应该分析在哪个时候添加连接符号。我们可以看出，在符号”)”,”*“后需要判断下一个元素是否为非符号或左括号，然后在其后压入一个连接符号入栈。同理，在非符号后也需要做上述判断和处理。</p>
<p>具体运算细节：  </p>
<ol>
<li>连接运算。需要弹出NFA栈中的两个NFA，将一个NFA的end连接到另一个NFA的start，再将新的NFA压入NFA栈内。</li>
<li>选择运算。需要弹出NFA栈中的两个NFA，重新分配两个新的节点，作为新的NFA的start和end，然后把新的NFA的start连到两个NFA的start中，两个NFA的end连到新的NFA的end中，再压入NFA栈。</li>
<li>闭包运算。需要弹出NFA栈中的一个NFA，然后重新分配两个新节点，作为新NFA的start和end, 然后新的start连接弹出的NFA的start，弹出的NFA的end连接新的end。然后新的start连到新的end的一条空边和旧的end连到旧的start的一条空边。最后把新的NFA压入NFA栈内。<br>如下图所示：<br><img src="/images/calculate.jpg" alt="Alt text"></li>
</ol>
<p>整个程序的具体过程应是如下：  </p>
<ol>
<li>用户输入一个正则表达式，用String来进行存储。  </li>
<li>遍历这个正则表达式，对非符号和符号做上文对应讲述的操作。</li>
<li>遍历完毕后，检查符号栈是否为空，若不为空，则弹出所有符号做对应的运算直至符号栈为空。</li>
<li>最后NFA栈中唯一的NFA就是所求的NFA。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>编译原理中的词法分析作业真的是折磨死我了。熬夜弄了一个不完美的版本。在此总结一下。<br>]]>
    
    </summary>
    
      <category term="Compile" scheme="http://weirdforce.com/tags/Compile/"/>
    
      <category term="编译原理" scheme="http://weirdforce.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="词法分析" scheme="http://weirdforce.com/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
      <category term="Compile" scheme="http://weirdforce.com/categories/Compile/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[恢复使用]]></title>
    <link href="http://weirdforce.com/2017/04/28/resume/"/>
    <id>http://weirdforce.com/2017/04/28/resume/</id>
    <published>2017-04-28T07:11:15.000Z</published>
    <updated>2017-04-28T07:12:47.000Z</updated>
    <content type="html"><![CDATA[<p>总算重新布置好了博客，最近开始慢慢把这一年学到的东西进行详细的记录。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>总算重新布置好了博客，最近开始慢慢把这一年学到的东西进行详细的记录。</p>
]]>
    </summary>
    
      <category term="恢复" scheme="http://weirdforce.com/tags/%E6%81%A2%E5%A4%8D/"/>
    
      <category term="blog" scheme="http://weirdforce.com/categories/blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Exchange Cards]]></title>
    <link href="http://weirdforce.com/2016/05/19/Exchange-Cards/"/>
    <id>http://weirdforce.com/2016/05/19/Exchange-Cards/</id>
    <published>2016-05-19T07:05:30.000Z</published>
    <updated>2017-04-28T07:10:59.000Z</updated>
    <content type="html"><![CDATA[<p>题目讲述了一个等价交换卡片的故事，其实是为了统计一个价值为n的卡片有多少种组合方式。<br><strong> 题目链接:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2734" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>题目思路：</p>
<blockquote>
<p>根据现有卡片对能够构成价值n的卡片，进行DFS，找出所有能构成的方式，统计。</p>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="keyword">struct</span> card
{
<span class="keyword">int</span> val;
<span class="keyword">int</span> num;
}a[<span class="number">11</span>];
<span class="keyword">int</span> m;
<span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*p1, <span class="keyword">const</span> <span class="keyword">void</span>*p2)</span>
</span>{
<span class="keyword">return</span> (*(card*)p1).val&gt;(*(card*)p2).val?-<span class="number">1</span>:<span class="number">1</span>;
}
<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> start ,<span class="keyword">int</span> &amp;cnt)</span>
</span>{
      <span class="keyword">if</span>(sum==<span class="number">0</span>)
      {
          cnt++;
      }
      <span class="keyword">else</span>
      {
          <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;m;i++)
          {
              <span class="keyword">if</span>(a[i].val&lt;=sum &amp;&amp; a[i].num )
              {
                  sum-=a[i].val;
                  a[i].num--;
                  DFS(sum,i,cnt);
                  a[i].num++;
                  sum+=a[i].val;
              }
          }
      }
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> n;
<span class="keyword">int</span> cnt;
<span class="keyword">int</span> u=<span class="number">0</span>;
<span class="keyword">int</span> sum;
<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)
{
    <span class="keyword">if</span>(u)
            <span class="built_in">cout</span>&lt;&lt;endl;
    <span class="keyword">else</span>
            u++;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)
    {
      <span class="built_in">cin</span>&gt;&gt;a[i].val&gt;&gt;a[i].num;
    }

    qsort(a,m,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]),comp);
    cnt=<span class="number">0</span>;
    sum=n;
    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)
    {
      <span class="keyword">if</span>(a[i].val&lt;=n)
      {
          sum-=a[i].val;
          a[i].num--;
          DFS(sum,i,cnt);
          a[i].num++;
          sum+=a[i].val;
      }
    }
    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;endl;
}
<span class="keyword">return</span> <span class="number">0</span>;

}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>题目讲述了一个等价交换卡片的故事，其实是为了统计一个价值为n的卡片有多少种组合方式。<br><strong> 题目链接:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2734">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ZOJ" scheme="http://weirdforce.com/tags/ZOJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Eight]]></title>
    <link href="http://weirdforce.com/2016/05/19/Eight/"/>
    <id>http://weirdforce.com/2016/05/19/Eight/</id>
    <published>2016-05-19T06:57:35.000Z</published>
    <updated>2017-04-28T07:03:07.000Z</updated>
    <content type="html"><![CDATA[<p>这题题意很好理解，就是给定模版，然后每次输入一个例子，计算出转换成模版所需的路径。<br><strong> 题目链接: <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1217" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a></p>
<p>题目思路如下：</p>
<blockquote>
<ol>
<li>先将模版确定，并用DFS将所有可能移动到模版的情况的路径都统计出来。</li>
<li>输入给出的例子，并从所有的情况中找出对应的路径输出</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;M;
<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
   <span class="built_in">string</span> gold=<span class="string">"12345678x"</span>;
   <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator my_it;
   <span class="keyword">bool</span> flag[<span class="number">8</span>];
   <span class="keyword">int</span> n;
   <span class="keyword">int</span> a[<span class="number">4</span>]={<span class="number">1</span>,-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">3</span>};
   q.push(gold);
   M[gold]=gold;
   <span class="keyword">while</span>(!q.empty())
   {
        n=<span class="number">0</span>;
        <span class="built_in">string</span> s=q.front();
        q.pop();
        <span class="keyword">while</span>(s[n]!=<span class="string">'x'</span>)
        {
            n++;
        }
        <span class="built_in">string</span> ts;
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)
        {
           ts=s;
           <span class="keyword">if</span>(n%<span class="number">3</span>+a[i]&gt;<span class="number">2</span>||n%<span class="number">3</span>+a[i]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;
           <span class="keyword">int</span> tx=n+a[i];
           <span class="keyword">char</span> tc;
           tc=ts[tx];
           ts[tx]=ts[n];
           ts[n]=tc;
           my_it = M.find(ts);
           <span class="keyword">if</span>(my_it==M.end())
           {
              q.push(ts);
              M[ts]=s;
           }
        }
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">4</span>;i++)
        {
            ts=s;
            <span class="keyword">if</span>(n+a[i]&gt;=<span class="number">8</span>||n+a[i]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;
            <span class="keyword">int</span> tx=n+a[i];
            <span class="keyword">char</span> tc;
            tc=ts[tx];
            ts[tx]=ts[n];
            ts[n]=tc;
            my_it = M.find(ts);
            <span class="keyword">if</span>(my_it==M.end())
            {
                   q.push(ts);
                   M[ts]=s;
            }
         }
    }
    <span class="built_in">string</span> is;
    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,is))
    {
        <span class="keyword">int</span> begin = <span class="number">0</span>;

        begin = is.find(<span class="string">" "</span>,begin);  <span class="comment">//查找空格在str中第一次出现的位置</span>

        <span class="keyword">while</span>(begin != -<span class="number">1</span>)  <span class="comment">//表示字符串中存在空格</span>
        {
        is.replace(begin, <span class="number">1</span>, <span class="string">""</span>);  <span class="comment">// 用空串替换str中从begin开始的1个字符</span>
        begin = is.find(<span class="string">" "</span>,begin);  <span class="comment">//查找空格在替换后的str中第一次出现的位置</span>
        }
        my_it = M.find(is);
        <span class="keyword">if</span>(my_it==M.end())
        {
           <span class="built_in">cout</span>&lt;&lt;<span class="string">"unsolvable"</span>&lt;&lt;endl;
           <span class="keyword">continue</span>;
        }
        <span class="built_in">string</span> str1,str2;
        <span class="keyword">int</span> w;
        str2=is;
        <span class="keyword">while</span>(<span class="number">1</span>)
        {
                str1=M[str2];
                <span class="keyword">int</span> ix=<span class="number">0</span>,iy=<span class="number">0</span>;
                <span class="keyword">while</span>(str1[ix]!=<span class="string">'x'</span>)
                {
                   ix++;
                }
                <span class="keyword">while</span>(str2[iy]!=<span class="string">'x'</span>)
                {
                   iy++;
                }
                <span class="keyword">switch</span>(ix-iy)
                {
                       <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"d"</span>;<span class="keyword">break</span>;
                       <span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"r"</span>;<span class="keyword">break</span>;
                       <span class="keyword">case</span> -<span class="number">1</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"l"</span>;<span class="keyword">break</span>;
                       <span class="keyword">case</span> -<span class="number">3</span>:<span class="built_in">cout</span>&lt;&lt;<span class="string">"u"</span>;<span class="keyword">break</span>;
                }
                str2=str1;
                <span class="keyword">if</span>(str1==gold)
                       <span class="keyword">break</span>;
        }
        <span class="built_in">cout</span>&lt;&lt;endl;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这题题意很好理解，就是给定模版，然后每次输入一个例子，计算出转换成模版所需的路径。<br><strong> 题目链接: <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1217">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ZOJ" scheme="http://weirdforce.com/tags/ZOJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Additive equations]]></title>
    <link href="http://weirdforce.com/2016/05/19/Additive-equations/"/>
    <id>http://weirdforce.com/2016/05/19/Additive-equations/</id>
    <published>2016-05-19T06:50:24.000Z</published>
    <updated>2017-04-28T07:04:40.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 题目链接:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1204" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>这题题意为从一个数字序列中找出所有可能出现的等式。</p>
<p>题目思路如下：</p>
<blockquote>
<ol>
<li>如果单纯地采用枚举法一个个找出等式，绝对会超时。</li>
<li>故选择DFS，因为每个数字都有属于自己的等式，故借此对每个数字进行拆分，并记录所有情况，得到结果。</li>
</ol>
</blockquote>
<p>代码如下:</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="keyword">int</span> a[<span class="number">35</span>];
<span class="keyword">int</span> n;
<span class="keyword">bool</span> visit[<span class="number">35</span>],flag;

<span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">int</span> len,<span class="keyword">int</span> start)</span>
</span>{
    <span class="keyword">if</span>(len==<span class="number">0</span>)
    {
        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;n &amp;&amp; sum &gt;= a[i];i++)
        {
               <span class="keyword">if</span>(sum == a[i])
               {
                   flag = <span class="literal">true</span>;
                   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=i; j++)
                   {
                       <span class="keyword">if</span>(visit[j])
                       {
                               <span class="keyword">if</span>(sum == a[j])
                                   <span class="built_in">printf</span>(<span class="string">"%d=%d\n"</span>,a[j],a[i]);
                               <span class="keyword">else</span>
                                   <span class="built_in">printf</span>(<span class="string">"%d+"</span>,a[j]);
                               sum-=a[j];
                       }
                   }    
               }
             }
     }
     <span class="keyword">else</span>
     {
        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++)
        {
            <span class="keyword">if</span>(sum+a[i] &lt;= a[n-<span class="number">1</span>])
            {   
                len--;
                visit[i]=<span class="literal">true</span>;
                sum+=a[i];
                DFS(sum,len,i+<span class="number">1</span>);
                sum-=a[i];
                visit[i]=<span class="literal">false</span>;
                len++;
            }

        }

     }
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> t;
<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);
<span class="keyword">while</span>(t--)
{
<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)
        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);
sort(a,a+n);
<span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visit));                    
flag = <span class="literal">false</span>;
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n;i++)
        DFS(<span class="number">0</span>,i,<span class="number">0</span>);
<span class="keyword">if</span>(!flag)
        <span class="built_in">printf</span>(<span class="string">"Can't find any equations.\n\n"</span>);
<span class="keyword">else</span>
        <span class="built_in">printf</span>(<span class="string">"\n"</span>);
}

<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 题目链接:<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1204">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ZOJ" scheme="http://weirdforce.com/tags/ZOJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016深圳杯笔记]]></title>
    <link href="http://weirdforce.com/2016/04/18/MCM-2016/"/>
    <id>http://weirdforce.com/2016/04/18/MCM-2016/</id>
    <published>2016-04-18T06:47:04.000Z</published>
    <updated>2017-04-28T06:49:15.000Z</updated>
    <content type="html"><![CDATA[<p>A题思路：<br>稳定性－&gt;单位面积烟尘排放量<br><a id="more"></a><br>影响稳定性的因素：</p>
<blockquote>
<p>布袋寿命<br>炉压差<br>布袋直径<br>喷嘴与布袋口中心偏差？<br>清洗频繁，喷吹压力过高<br>输灰系统<br>布袋底部强度</p>
</blockquote>
<p>除尘效果：</p>
<blockquote>
<p>烟气温度<br>烟道和本体漏风漏水</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>A题思路：<br>稳定性－&gt;单位面积烟尘排放量<br>]]>
    
    </summary>
    
      <category term="MCM" scheme="http://weirdforce.com/tags/MCM/"/>
    
      <category term="2016深圳杯" scheme="http://weirdforce.com/tags/2016%E6%B7%B1%E5%9C%B3%E6%9D%AF/"/>
    
      <category term="MCM" scheme="http://weirdforce.com/categories/MCM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015深圳杯数学建模A题笔记(2)]]></title>
    <link href="http://weirdforce.com/2016/04/09/MCM-note-2/"/>
    <id>http://weirdforce.com/2016/04/09/MCM-note-2/</id>
    <published>2016-04-09T06:39:05.000Z</published>
    <updated>2017-04-28T06:46:53.000Z</updated>
    <content type="html"><![CDATA[<p>采用基于分辨率的孤立点算法（RB算法）<br>RB算法：</p>
<blockquote>
<p><strong>优点：</strong> 适用于海量的数据库，无需引入参数<br><strong>缺点：</strong> RB算法仅从数据集全局出发寻找孤立点，会导致孤立点的寻找过程中忽略了数据点所在的类的密集程度对孤立点的影响。<br><a id="more"></a><br>所以，在RB算法基础上，提出了密集度加权的分辨率孤立点挖掘算法（WRB算法）。<br>主要是通过计算每个孤立点相距最近的类的稠密度测度作为分辨率的权重，从全局和局部出发，综合考虑数据点周围的点的个数以及每个孤立点与距离本身最近的类的密集度对比计算每个数据点的孤立程度。</p>
</blockquote>
<p>就病人取药时间，将病人的取药时间看作一个个点，将点的个数及密集程度赋值，将一个病人的取药时间量化成一个值，使用一维格子分布密集度算法对其密集度进行度量，从而排序。最后结合实际，进一步剔除混合度密度算法。</p>
<p>最后,代入模型，RB算法以及WRB算法的交集即为可能用高额处方骗保的病人，而利用混合密度算法得出的孤立程度较大的点，即为可能存在骗保的病人。</p>
<p><strong>数据预处理步骤：</strong></p>
<blockquote>
<ol>
<li><strong>数据清洗：</strong>对于数据缺失项，根据其余各表补充，若无法补充关键则删除该数据。去除前后属性明显矛盾可能是由于记录错误而引起的数据项，如药品单价与费用为负值。</li>
<li><strong>目标数据提取：</strong>以同一账单号为条件，对数据进行条件加和，得到一个个对应一定费用的账单。此外对于每个病人的取药次数与分布也进行了提取。</li>
<li><strong>数据规范化：</strong> 由于给出的费用范围太大，造成计算复杂度大大提高，故将数据属性数据按比例缩放，使之落入一个小的特定区间。</li>
</ol>
</blockquote>
<p><strong>假设：</strong></p>
<blockquote>
<ol>
<li>不考虑科室只有一个人得某种病，导致此数据与儿科中其他数据明显不同，默认为每种病都有几个可用的数据。</li>
<li>不考虑某病人分开多次配药，默认每个病人就配一次或者极少次。即一个处方对应一个账单号。</li>
<li>只考虑费用的总和，某种费用有问题可视为总费用有问题。</li>
<li>不考虑由于特殊情况出现需要过多取药的情况。</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>采用基于分辨率的孤立点算法（RB算法）<br>RB算法：</p>
<blockquote>
<p><strong>优点：</strong> 适用于海量的数据库，无需引入参数<br><strong>缺点：</strong> RB算法仅从数据集全局出发寻找孤立点，会导致孤立点的寻找过程中忽略了数据点所在的类的密集程度对孤立点的影响。<br>]]>
    
    </summary>
    
      <category term="MCM" scheme="http://weirdforce.com/tags/MCM/"/>
    
      <category term="2015深圳杯" scheme="http://weirdforce.com/tags/2015%E6%B7%B1%E5%9C%B3%E6%9D%AF/"/>
    
      <category term="A题" scheme="http://weirdforce.com/tags/A%E9%A2%98/"/>
    
      <category term="MCM" scheme="http://weirdforce.com/categories/MCM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015深圳杯数学建模A题笔记(1)]]></title>
    <link href="http://weirdforce.com/2016/03/31/MCM-note-1/"/>
    <id>http://weirdforce.com/2016/03/31/MCM-note-1/</id>
    <published>2016-03-31T04:43:49.000Z</published>
    <updated>2017-04-28T04:51:32.000Z</updated>
    <content type="html"><![CDATA[<p><strong> 辅助学习（有监督）的方法 </strong>：统计回归，神经网络。<br><strong> 非辅助学习（无监督）方法 </strong>：<br><strong> 聚类分析 </strong>：在经典的情况下将不同指标视作等同的，忽略了指标间权重的差异，影响了分类的精度。<br><a id="more"></a><br><strong> 步骤：</strong></p>
<blockquote>
<ol>
<li>引入基于指标权重的欧氏距离，刻画数据之间的相似程度</li>
<li>通过聚类算法将数据按照相似程度不同分成多类，分类中出现的孤立点即为意思欺诈点。 权重指标评价函数CFuzziness(w)<br>该函数刻画随着权重w的改变，分类的模糊程度的变化。</li>
</ol>
</blockquote>
<p><strong> 粒子群优化（MPSO）算法： </strong><br>极小化属性权重评价函数，得到每个指标的权重赋值。将得到的权重应用于聚类算法。</p>
<p><strong> 建立模型过程：</strong></p>
<blockquote>
<ol>
<li>筛选与处理数据，剔除显著无关的指标与无效的交易记录；</li>
<li>构造属性权重评价函数CFuzziness(w),用以描述聚类效果的不确定性，通过粒子群优化算法求得属性权重评价函数取得最小值得最优解w作为各项属性的权重。</li>
<li>构造改进的欧氏距离函数d，用改进的欧式距离作为聚类函数的输入；</li>
<li>应用聚类分析算法，无监督给出样本数据分类，以区分正常医保消费与欺诈记录；</li>
</ol>
</blockquote>
<p><strong> 冗余项忽略： </strong><br>排除身高、性别、所在省份等信息对结果影响</p>
<p><strong> 指标确定： </strong></p>
<blockquote>
<ol>
<li>欺诈行为的主体一定是有医保的患者。故筛选掉无医保患者的取药记录。</li>
<li>两种欺诈类型表现为单张账单价格过高以及拿药次数过于频繁。故将单张账单总价格和单个患者拿药次数应该分别作为判断是否为欺诈的第一项和第二项的指标。</li>
<li>生活经验：部分科室、或者个别医生可能存在不合理开医嘱作为患者取药凭证的现象。故把执行科室以及开嘱医生ID作为影响判断是否欺诈的第三项和第四项指标。</li>
<li>考虑有一种欺诈类型是刷他人的医保卡，可能存在部分人经常将自己的医保卡外借的情况，所以将患者ID作为影响判断是否为欺诈的结果的第五项指标。</li>
</ol>
</blockquote>
<p><strong> 操作过程：</strong></p>
<blockquote>
<ol>
<li>从表格2.1中，导入患者ID和医保手册号－－根据是否有医保手册判断患者是否有医保，筛掉表格2.2中无医保患者的购药记录。</li>
<li>为了得到单张账单的总价以及患者的购药次数，从表格2.2中导入账单号、价格、患者ID＝＝将账单号相同的记录合并，进而计算出单张单据的总价；根据患者ID来统计每位患者的购药次数。</li>
<li>考虑到影响判断是否欺诈的其他因素，将表格2.2执行科室和开嘱医生ID导入Matlab中。</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong> 辅助学习（有监督）的方法 </strong>：统计回归，神经网络。<br><strong> 非辅助学习（无监督）方法 </strong>：<br><strong> 聚类分析 </strong>：在经典的情况下将不同指标视作等同的，忽略了指标间权重的差异，影响了分类的精度。<br>]]>
    
    </summary>
    
      <category term="MCM" scheme="http://weirdforce.com/tags/MCM/"/>
    
      <category term="2015深圳杯" scheme="http://weirdforce.com/tags/2015%E6%B7%B1%E5%9C%B3%E6%9D%AF/"/>
    
      <category term="A题" scheme="http://weirdforce.com/tags/A%E9%A2%98/"/>
    
      <category term="MCM" scheme="http://weirdforce.com/categories/MCM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Quicksum]]></title>
    <link href="http://weirdforce.com/2016/03/12/Quicksum/"/>
    <id>http://weirdforce.com/2016/03/12/Quicksum/</id>
    <published>2016-03-12T04:37:33.000Z</published>
    <updated>2017-04-28T04:41:31.000Z</updated>
    <content type="html"><![CDATA[<p>这道题十分简单，不过需要注意使用gets函数～</p>
<p><strong> 题目链接:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2734" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a></p>
<p>解题思路：</p>
<blockquote>
<ol>
<li>清楚每个字母的ASCII值，将其值减去64得到1～26。</li>
<li>注意空格占一个位置，所以必须将空格输入。</li>
<li>空格的值为0，在统计的总数中可以进行排除。</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">char</span> str[<span class="number">256</span>]={<span class="number">0</span>};
    <span class="keyword">int</span> total,i;
    <span class="keyword">while</span>(gets(str))
    {
        total=<span class="number">0</span>;
        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'#'</span>)
                <span class="keyword">break</span>;
        <span class="keyword">for</span>(i=<span class="number">0</span>;str[i] !=<span class="string">'\0'</span>;i++)
        {
                 <span class="keyword">if</span>(str[i] != <span class="string">' '</span>)
                     total+=(str[i]-<span class="number">64</span>) * (i+<span class="number">1</span>);
        }
        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,total);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这道题十分简单，不过需要注意使用gets函数～</p>
<p><strong> 题目链接:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2734">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Palindrom Numbers]]></title>
    <link href="http://weirdforce.com/2016/03/12/Palindrom-Numbers/"/>
    <id>http://weirdforce.com/2016/03/12/Palindrom-Numbers/</id>
    <published>2016-03-12T04:28:58.000Z</published>
    <updated>2017-04-28T04:36:06.000Z</updated>
    <content type="html"><![CDATA[<p>这是一道检验回文数的程序（在2～16进制下）～</p>
<p><strong> 题目链接：<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1078" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>思路大致如下：</p>
<blockquote>
<ol>
<li>需要一个字符数组用于记录输入数在某进制下的表示数，然后对其进行头尾回文比较。</li>
<li>需要一个数组记录输入数在哪些进制下存在回文数或它根本不是回文数。</li>
<li>用循环去实现对每个输入数在哪些进制下为回文数的判断</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> n,i,x;
    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)
      {
        x=<span class="number">0</span>;
        <span class="keyword">char</span> s[<span class="number">16</span>]={<span class="number">0</span>};
        <span class="keyword">int</span> b[<span class="number">15</span>]={<span class="number">0</span>};
        <span class="keyword">int</span> j;
        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=<span class="number">16</span>;j++)
        {
        <span class="keyword">int</span> p=n;
        i=<span class="number">0</span>;
        <span class="keyword">while</span>(p)
        {
            s[i]=p%j;
            i++;
            p/=j;
        }
        <span class="keyword">int</span> k;
        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;i/<span class="number">2</span>;k++)
        {
                <span class="keyword">if</span>(s[k]!=s[i-k-<span class="number">1</span>])
                    <span class="keyword">break</span>;
        }
        <span class="keyword">if</span>(k&gt;=i/<span class="number">2</span>)
            b[x++]=j;
        }
        <span class="keyword">if</span>(x==<span class="number">0</span>)
            <span class="built_in">printf</span>(<span class="string">"Number %d is not a palindrom\n"</span>,n);
        <span class="keyword">else</span>
        {
            <span class="built_in">printf</span>(<span class="string">"Number %d is palindrom in basis"</span>,n);
            <span class="keyword">int</span> m;
            <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;x;m++)
                <span class="built_in">printf</span>(<span class="string">" %d"</span>,b[m]);
            <span class="built_in">printf</span>(<span class="string">"\n"</span>);
        }
}
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这是一道检验回文数的程序（在2～16进制下）～</p>
<p><strong> 题目链接：<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1078">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ZOJ" scheme="http://weirdforce.com/tags/ZOJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[I Think I Need a Houseboat]]></title>
    <link href="http://weirdforce.com/2016/03/12/I-Think-I-Need-a-Houseboat/"/>
    <id>http://weirdforce.com/2016/03/12/I-Think-I-Need-a-Houseboat/</id>
    <published>2016-03-12T04:25:33.000Z</published>
    <updated>2017-04-28T04:27:56.000Z</updated>
    <content type="html"><![CDATA[<p>刚刚AC了一道题目，又是一道数学题目～<br><strong> 题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1065" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a></p>
<p>解题思路如下：</p>
<blockquote>
<ol>
<li>因题意可知每年面积增大50平方英里，形状为半圆，可以直接得到半径的平方。</li>
<li>输入的坐标到原点的距离平方为 x的平方+y的平方。</li>
<li>最后将1，2两个数据进行相除就能得到年数。<br>  (Tips: 要注意的是，不足一年按一年计，年数为整数)</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> t,count1;
<span class="keyword">double</span> x,y;
<span class="built_in">cin</span>&gt;&gt;t;
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)
{
    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;
    count1=<span class="built_in">ceil</span>((x*x+y*y)*<span class="number">3.1419</span>/<span class="number">100</span>);
    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Property "</span>&lt;&lt;i&lt;&lt;<span class="string">": This property will begin eroding in year     "</span>&lt;&lt;count1&lt;&lt;<span class="string">"."</span>&lt;&lt;endl;
}
<span class="built_in">cout</span>&lt;&lt;<span class="string">"END OF OUTPUT."</span>&lt;&lt;endl;
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>刚刚AC了一道题目，又是一道数学题目～<br><strong> 题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1065">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Financial Management]]></title>
    <link href="http://weirdforce.com/2016/03/12/Financial-Management/"/>
    <id>http://weirdforce.com/2016/03/12/Financial-Management/</id>
    <published>2016-03-12T04:20:28.000Z</published>
    <updated>2017-04-28T04:24:22.000Z</updated>
    <content type="html"><![CDATA[<p>前几天AC的一道简单题目～学到了一些东西～</p>
<p><strong> 题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1064" target="_blank" rel="external">题目</a> </strong></p>
<a id="more"></a>
<p>题目比较简单，思路就是输入十二个月的金额求平均值(保留两位小数，四舍五入)。<br>这题我WA了很多次，原因是：</p>
<blockquote>
<p>1.在C语言中double 类型必须用%lf形式输入，而输出可以为%f。<br>2.不用纠结于题目所给的四舍五入。</p>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> 
</span>{ 
<span class="keyword">double</span> a; 
<span class="keyword">int</span> i; 
<span class="keyword">double</span> count1=<span class="number">0</span>; 
<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++) 
{ 
<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a); 
count1+=a; 
} 
<span class="built_in">printf</span>(<span class="string">"$%.2f\n"</span>, count1/<span class="number">12</span>); 
<span class="keyword">return</span> <span class="number">0</span>; 
} 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>前几天AC的一道简单题目～学到了一些东西～</p>
<p><strong> 题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1064">题目</a> </strong></p>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="HDU" scheme="http://weirdforce.com/tags/HDU/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Color Me Less]]></title>
    <link href="http://weirdforce.com/2016/03/12/Color-Me-Less/"/>
    <id>http://weirdforce.com/2016/03/12/Color-Me-Less/</id>
    <published>2016-03-12T04:13:35.000Z</published>
    <updated>2017-04-28T04:19:05.000Z</updated>
    <content type="html"><![CDATA[<p>又是一道比较简单的题目～</p>
<p><strong> 题目链接: <a href="http://poj.org/problem?id=1046" target="_blank" rel="external">题目</a> </strong><br><a id="more"></a><br>题目思路如下：</p>
<blockquote>
<ol>
<li>输入16组已知RGB，输出余下输入所对应的映射。</li>
<li>映射是由距离公式决定的，那么在已知RGB中找出与输入RGB距离最小的RGB为所求RGB。</li>
</ol>
</blockquote>
<p>代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
<span class="keyword">int</span> r[<span class="number">17</span>],g[<span class="number">17</span>],b[<span class="number">17</span>];
<span class="keyword">int</span> s,t,u,num;
<span class="keyword">int</span> min;
<span class="keyword">int</span> d;
<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">15</span>;i++)
{
    <span class="built_in">cin</span>&gt;&gt;r[i]&gt;&gt;g[i]&gt;&gt;b[i];
}
<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t&gt;&gt;u &amp;&amp; u!=-<span class="number">1</span> &amp;&amp; s!=-<span class="number">1</span> &amp;&amp; t!=-<span class="number">1</span>)
{
   min=<span class="number">200000</span>;
   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">15</span>;i++)
   {
           d= (s-r[i])*(s-r[i])+(t-g[i])*(t-g[i])+(u-b[i])*(u-b[i]);
           <span class="keyword">if</span>(min &gt; d)
           {
           min = d;
           num = i;
           }
   }
   <span class="built_in">cout</span>&lt;&lt;<span class="string">"("</span>&lt;&lt;s&lt;&lt;<span class="string">","</span>&lt;&lt;t&lt;&lt;<span class="string">","</span>&lt;&lt;u&lt;&lt;<span class="string">") maps to ("</span>&lt;&lt;r[num]&lt;&lt;<span class="string">","</span>&lt;&lt;g[num]&lt;&lt;<span class="string">","</span>&lt;&lt;b[num]&lt;&lt;<span class="string">")"</span>&lt;&lt;endl;
}
<span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>又是一道比较简单的题目～</p>
<p><strong> 题目链接: <a href="http://poj.org/problem?id=1046">题目</a> </strong><br>]]>
    
    </summary>
    
      <category term="ACM" scheme="http://weirdforce.com/tags/ACM/"/>
    
      <category term="算法" scheme="http://weirdforce.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="POJ" scheme="http://weirdforce.com/tags/POJ/"/>
    
      <category term="ACM" scheme="http://weirdforce.com/categories/ACM/"/>
    
  </entry>
  
</feed>
